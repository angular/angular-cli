## API Report File for "@angular-devkit/core"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { ErrorObject } from 'ajv';
import { Format } from 'ajv';
import { Observable } from 'rxjs';
import { ObservableInput } from 'rxjs';
import { Operator } from 'rxjs';
import { PartialObserver } from 'rxjs';
import { Position } from 'source-map';
import { Subject } from 'rxjs';
import { Subscription } from 'rxjs';
import { ValidateFunction } from 'ajv';

// @public (undocumented)
function addUndefinedDefaults(value: JsonValue, _pointer: JsonPointer, schema?: JsonSchema): JsonValue;

// @public
class AliasHost<StatsT extends object = {}> extends ResolverHost<StatsT> {
    // (undocumented)
    get aliases(): Map<Path, Path>;
    // (undocumented)
    protected _aliases: Map<Path, Path>;
    // (undocumented)
    protected _resolve(path: Path): Path;
}

// @public (undocumented)
export function asPosixPath(path: Path): PosixPath;

// @public (undocumented)
export function asWindowsPath(path: Path): WindowsPath;

// @public
export class BaseException extends Error {
    constructor(message?: string);
}

// @public
export function basename(path: Path): PathFragment;

// @public (undocumented)
function buildJsonPointer(fragments: string[]): JsonPointer;

// @public
function camelize(str: string): string;

// @public
function capitalize(str: string): string;

// @public (undocumented)
export class CircularDependencyFoundException extends BaseException {
    constructor();
}

// @public
function classify(str: string): string;

// @public
class CordHost extends SimpleMemoryHost {
    constructor(_back: ReadonlyHost);
    // (undocumented)
    protected _back: ReadonlyHost;
    // (undocumented)
    get backend(): ReadonlyHost;
    // (undocumented)
    get capabilities(): HostCapabilities;
    clone(): CordHost;
    commit(host: Host, force?: boolean): Observable<void>;
    create(path: Path, content: FileBuffer): Observable<void>;
    // (undocumented)
    delete(path: Path): Observable<void>;
    // (undocumented)
    exists(path: Path): Observable<boolean>;
    // (undocumented)
    protected _filesToCreate: Set<Path>;
    // (undocumented)
    protected _filesToDelete: Set<Path>;
    // (undocumented)
    protected _filesToOverwrite: Set<Path>;
    // (undocumented)
    protected _filesToRename: Map<Path, Path>;
    // (undocumented)
    protected _filesToRenameRevert: Map<Path, Path>;
    // (undocumented)
    isDirectory(path: Path): Observable<boolean>;
    // (undocumented)
    isFile(path: Path): Observable<boolean>;
    // (undocumented)
    list(path: Path): Observable<PathFragment[]>;
    // (undocumented)
    overwrite(path: Path, content: FileBuffer): Observable<void>;
    // (undocumented)
    read(path: Path): Observable<FileBuffer>;
    // (undocumented)
    records(): CordHostRecord[];
    // (undocumented)
    rename(from: Path, to: Path): Observable<void>;
    // (undocumented)
    stat(path: Path): Observable<Stats | null> | null;
    // (undocumented)
    watch(path: Path, options?: HostWatchOptions): null;
    // (undocumented)
    willCreate(path: Path): boolean;
    // (undocumented)
    willDelete(path: Path): boolean;
    // (undocumented)
    willOverwrite(path: Path): boolean;
    // (undocumented)
    willRename(path: Path): boolean;
    // (undocumented)
    willRenameTo(path: Path, to: Path): boolean;
    // (undocumented)
    write(path: Path, content: FileBuffer): Observable<void>;
}

// @public (undocumented)
interface CordHostCreate {
    // (undocumented)
    content: FileBuffer;
    // (undocumented)
    kind: 'create';
    // (undocumented)
    path: Path;
}

// @public (undocumented)
interface CordHostDelete {
    // (undocumented)
    kind: 'delete';
    // (undocumented)
    path: Path;
}

// @public (undocumented)
interface CordHostOverwrite {
    // (undocumented)
    content: FileBuffer;
    // (undocumented)
    kind: 'overwrite';
    // (undocumented)
    path: Path;
}

// @public (undocumented)
type CordHostRecord = CordHostCreate | CordHostOverwrite | CordHostRename | CordHostDelete;

// @public (undocumented)
interface CordHostRename {
    // (undocumented)
    from: Path;
    // (undocumented)
    kind: 'rename';
    // (undocumented)
    to: Path;
}

// @public (undocumented)
class CoreSchemaRegistry implements SchemaRegistry {
    constructor(formats?: SchemaFormat[]);
    // (undocumented)
    addFormat(format: SchemaFormat): void;
    addPostTransform(visitor: JsonVisitor, deps?: JsonVisitor[]): void;
    addPreTransform(visitor: JsonVisitor, deps?: JsonVisitor[]): void;
    // (undocumented)
    addSmartDefaultProvider<T>(source: string, provider: SmartDefaultProvider<T>): void;
    compile(schema: JsonSchema): Promise<SchemaValidator>;
    // (undocumented)
    registerUriHandler(handler: UriHandler): void;
    // (undocumented)
    protected _resolver(ref: string, validate?: ValidateFunction): {
        context?: ValidateFunction;
        schema?: JsonObject;
    };
    // (undocumented)
    usePromptProvider(provider: PromptProvider): void;
    // (undocumented)
    useXDeprecatedProvider(onUsage: (message: string) => void): void;
    Éµflatten(schema: JsonObject): Promise<JsonObject>;
}

// @public (undocumented)
function createSyncHost<StatsT extends object = {}>(handler: SyncHostHandler<StatsT>): Host<StatsT>;

// @public (undocumented)
function createWorkspaceHost(host: virtualFs.Host): WorkspaceHost;

// @public
function dasherize(str: string): string;

// @public
function decamelize(str: string): string;

// @public
export function deepCopy<T>(value: T): T;

// @public (undocumented)
type DefinitionCollectionListener<V extends object> = (name: string, newValue: V | undefined, collection: DefinitionCollection<V>) => void;

// @public (undocumented)
export class DependencyNotFoundException extends BaseException {
    constructor();
}

// @public
export function dirname(path: Path): Path;

// @public (undocumented)
class Empty implements ReadonlyHost {
    // (undocumented)
    readonly capabilities: HostCapabilities;
    // (undocumented)
    exists(path: Path): Observable<boolean>;
    // (undocumented)
    isDirectory(path: Path): Observable<boolean>;
    // (undocumented)
    isFile(path: Path): Observable<boolean>;
    // (undocumented)
    list(path: Path): Observable<PathFragment[]>;
    // (undocumented)
    read(path: Path): Observable<FileBuffer>;
    // (undocumented)
    stat(path: Path): Observable<Stats<{}> | null>;
}

// @public (undocumented)
export function extname(path: Path): string;

// @public (undocumented)
export class FileAlreadyExistException extends BaseException {
    constructor(path: string);
}

// @public (undocumented)
type FileBuffer = ArrayBuffer;

// @public (undocumented)
type FileBufferLike = ArrayBufferLike;

// @public (undocumented)
function fileBufferToString(fileBuffer: FileBuffer): string;

// @public (undocumented)
export class FileDoesNotExistException extends BaseException {
    constructor(path: string);
}

// @public (undocumented)
export function fragment(path: string): PathFragment;

// @public (undocumented)
export function getSystemPath(path: Path): string;

// @public (undocumented)
function getTypesOfSchema(schema: JsonSchema): Set<string>;

// @public (undocumented)
interface Host<StatsT extends object = {}> extends ReadonlyHost<StatsT> {
    // (undocumented)
    delete(path: Path): Observable<void>;
    // (undocumented)
    rename(from: Path, to: Path): Observable<void>;
    // (undocumented)
    watch(path: Path, options?: HostWatchOptions): Observable<HostWatchEvent> | null;
    // (undocumented)
    write(path: Path, content: FileBufferLike): Observable<void>;
}

// @public (undocumented)
interface HostCapabilities {
    // (undocumented)
    synchronous: boolean;
}

// @public (undocumented)
interface HostWatchEvent {
    // (undocumented)
    readonly path: Path;
    // (undocumented)
    readonly time: Date;
    // (undocumented)
    readonly type: HostWatchEventType;
}

// @public (undocumented)
enum HostWatchEventType {
    // (undocumented)
    Changed = 0,
    // (undocumented)
    Created = 1,
    // (undocumented)
    Deleted = 2,
    // (undocumented)
    Renamed = 3
}

// @public (undocumented)
interface HostWatchOptions {
    // (undocumented)
    readonly persistent?: boolean;
    // (undocumented)
    readonly recursive?: boolean;
}

// @public (undocumented)
function indentBy(indentations: number): TemplateTag;

// @public (undocumented)
class IndentLogger extends Logger {
    constructor(name: string, parent?: Logger | null, indentation?: string);
}

// @public (undocumented)
export class InvalidPathException extends BaseException {
    constructor(path: string);
}

// @public
export function isAbsolute(p: Path): boolean;

// @public (undocumented)
export function isJsonArray(value: JsonValue): value is JsonArray;

// @public (undocumented)
export function isJsonObject(value: JsonValue): value is JsonObject;

// @public (undocumented)
function isJsonSchema(value: unknown): value is JsonSchema;

// @public
export function isPromise(obj: any): obj is Promise<any>;

// @public
export function join(p1: Path, ...others: string[]): Path;

// @public (undocumented)
function joinJsonPointer(root: JsonPointer, ...others: string[]): JsonPointer;

declare namespace json {
    export {
        schema,
        isJsonObject,
        isJsonArray,
        JsonArray,
        JsonObject,
        JsonValue
    }
}
export { json }

// @public
export interface JsonArray extends Array<JsonValue> {
}

// @public (undocumented)
export interface JsonObject {
    // (undocumented)
    [prop: string]: JsonValue;
}

// @public (undocumented)
type JsonPointer = string & {
    __PRIVATE_DEVKIT_JSON_POINTER: void;
};

// @public
type JsonSchema = JsonObject | boolean;

// @public (undocumented)
interface JsonSchemaVisitor {
    // (undocumented)
    (current: JsonObject | JsonArray, pointer: JsonPointer, parentSchema?: JsonObject | JsonArray, index?: string): void;
}

// @public (undocumented)
export type JsonValue = boolean | string | number | JsonArray | JsonObject | null;

// @public (undocumented)
interface JsonVisitor {
    // (undocumented)
    (value: JsonValue, pointer: JsonPointer, schema?: JsonObject, root?: JsonObject | JsonArray): Observable<JsonValue> | JsonValue;
}

// @public (undocumented)
class LevelCapLogger extends LevelTransformLogger {
    constructor(name: string, parent: (Logger | null) | undefined, levelCap: LogLevel);
    // (undocumented)
    readonly levelCap: LogLevel;
    // (undocumented)
    static levelMap: {
        [cap: string]: {
            [level: string]: string;
        };
    };
    // (undocumented)
    readonly name: string;
    // (undocumented)
    readonly parent: Logger | null;
}

// @public (undocumented)
class LevelTransformLogger extends Logger {
    constructor(name: string, parent: (Logger | null) | undefined, levelTransform: (level: LogLevel) => LogLevel);
    // (undocumented)
    createChild(name: string): Logger;
    // (undocumented)
    readonly levelTransform: (level: LogLevel) => LogLevel;
    // (undocumented)
    log(level: LogLevel, message: string, metadata?: JsonObject): void;
    // (undocumented)
    readonly name: string;
    // (undocumented)
    readonly parent: Logger | null;
}

// @public
function levenshtein(a: string, b: string): number;

// @public (undocumented)
interface LogEntry extends LoggerMetadata {
    // (undocumented)
    level: LogLevel;
    // (undocumented)
    message: string;
    // (undocumented)
    timestamp: number;
}

// @public (undocumented)
class Logger extends Observable<LogEntry> implements LoggerApi {
    constructor(name: string, parent?: Logger | null);
    // (undocumented)
    asApi(): LoggerApi;
    // (undocumented)
    complete(): void;
    // (undocumented)
    createChild(name: string): Logger;
    // (undocumented)
    debug(message: string, metadata?: JsonObject): void;
    // (undocumented)
    error(message: string, metadata?: JsonObject): void;
    // (undocumented)
    fatal(message: string, metadata?: JsonObject): void;
    // (undocumented)
    forEach(next: (value: LogEntry) => void, promiseCtor?: PromiseConstructorLike): Promise<void>;
    // (undocumented)
    info(message: string, metadata?: JsonObject): void;
    // (undocumented)
    lift<R>(operator: Operator<LogEntry, R>): Observable<R>;
    // (undocumented)
    log(level: LogLevel, message: string, metadata?: JsonObject): void;
    // (undocumented)
    protected _metadata: LoggerMetadata;
    // (undocumented)
    readonly name: string;
    // (undocumented)
    next(entry: LogEntry): void;
    // (undocumented)
    protected get _observable(): Observable<LogEntry>;
    protected set _observable(v: Observable<LogEntry>);
    // (undocumented)
    readonly parent: Logger | null;
    // (undocumented)
    protected readonly _subject: Subject<LogEntry>;
    // (undocumented)
    subscribe(): Subscription;
    // (undocumented)
    subscribe(observer: PartialObserver<LogEntry>): Subscription;
    // (undocumented)
    subscribe(next?: (value: LogEntry) => void, error?: (error: Error) => void, complete?: () => void): Subscription;
    // (undocumented)
    toString(): string;
    // (undocumented)
    warn(message: string, metadata?: JsonObject): void;
}

// @public (undocumented)
interface LoggerApi {
    // (undocumented)
    createChild(name: string): Logger;
    // (undocumented)
    debug(message: string, metadata?: JsonObject): void;
    // (undocumented)
    error(message: string, metadata?: JsonObject): void;
    // (undocumented)
    fatal(message: string, metadata?: JsonObject): void;
    // (undocumented)
    info(message: string, metadata?: JsonObject): void;
    // (undocumented)
    log(level: LogLevel, message: string, metadata?: JsonObject): void;
    // (undocumented)
    warn(message: string, metadata?: JsonObject): void;
}

// @public (undocumented)
interface LoggerMetadata extends JsonObject {
    // (undocumented)
    name: string;
    // (undocumented)
    path: string[];
}

declare namespace logging {
    export {
        IndentLogger,
        LevelTransformLogger,
        LevelCapLogger,
        LoggerMetadata,
        LogEntry,
        LoggerApi,
        LogLevel,
        Logger,
        NullLogger,
        TransformLogger
    }
}
export { logging }

// @public (undocumented)
type LogLevel = 'debug' | 'info' | 'warn' | 'error' | 'fatal';

// @public
function mergeSchemas(...schemas: (JsonSchema | undefined)[]): JsonSchema;

// @public
export function noCacheNormalize(path: string): Path;

// @public
export function normalize(path: string): Path;

// @public
export const NormalizedRoot: Path;

// @public
export const NormalizedSep: Path;

// @public (undocumented)
class NullLogger extends Logger {
    constructor(parent?: Logger | null);
    // (undocumented)
    asApi(): LoggerApi;
}

// @public (undocumented)
function oneLine(strings: TemplateStringsArray, ...values: any[]): string;

// @public (undocumented)
function parseJsonPointer(pointer: JsonPointer): string[];

// @public (undocumented)
export class PartiallyOrderedSet<T> implements Set<T> {
    // (undocumented)
    [Symbol.iterator](): Generator<T, undefined, unknown>;
    // (undocumented)
    get [Symbol.toStringTag](): 'Set';
    // (undocumented)
    add(item: T, deps?: Set<T> | T[]): this;
    // (undocumented)
    protected _checkCircularDependencies(item: T, deps: Set<T>): void;
    // (undocumented)
    clear(): void;
    // (undocumented)
    delete(item: T): boolean;
    entries(): IterableIterator<[T, T]>;
    // (undocumented)
    forEach(callbackfn: (value: T, value2: T, set: PartiallyOrderedSet<T>) => void, thisArg?: any): void;
    // (undocumented)
    has(item: T): boolean;
    keys(): IterableIterator<T>;
    // (undocumented)
    get size(): number;
    values(): IterableIterator<T>;
}

// @public
export type Path = string & {
    __PRIVATE_DEVKIT_PATH: void;
};

// @public (undocumented)
export const path: TemplateTag<Path>;

// @public (undocumented)
export class PathCannotBeFragmentException extends BaseException {
    constructor(path: string);
}

// @public
export type PathFragment = Path & {
    __PRIVATE_DEVKIT_PATH_FRAGMENT: void;
};

// @public (undocumented)
export class PathIsDirectoryException extends BaseException {
    constructor(path: string);
}

// @public (undocumented)
export class PathIsFileException extends BaseException {
    constructor(path: string);
}

// @public (undocumented)
export class PathMustBeAbsoluteException extends BaseException {
    constructor(path: string);
}

// @public (undocumented)
class PatternMatchingHost<StatsT extends object = {}> extends ResolverHost<StatsT> {
    // (undocumented)
    addPattern(pattern: string | string[], replacementFn: ReplacementFunction): void;
    // (undocumented)
    protected _patterns: Map<RegExp, ReplacementFunction>;
    // (undocumented)
    protected _resolve(path: Path): Path;
}

// @public (undocumented)
export type PosixPath = string & {
    __PRIVATE_DEVKIT_POSIX_PATH: void;
};

// @public
export class PriorityQueue<T> {
    constructor(_comparator: (x: T, y: T) => number);
    // (undocumented)
    clear(): void;
    // (undocumented)
    peek(): T | undefined;
    // (undocumented)
    pop(): T | undefined;
    // (undocumented)
    push(item: T): void;
    // (undocumented)
    get size(): number;
    // (undocumented)
    toArray(): Array<T>;
}

// @public (undocumented)
interface ProjectDefinition {
    // (undocumented)
    readonly extensions: Record<string, JsonValue | undefined>;
    // (undocumented)
    prefix?: string;
    // (undocumented)
    root: string;
    // (undocumented)
    sourceRoot?: string;
    // (undocumented)
    readonly targets: TargetDefinitionCollection;
}

// @public (undocumented)
class ProjectDefinitionCollection extends DefinitionCollection<ProjectDefinition> {
    constructor(initial?: Record<string, ProjectDefinition>, listener?: DefinitionCollectionListener<ProjectDefinition>);
    // (undocumented)
    add(definition: {
        name: string;
        root: string;
        sourceRoot?: string;
        prefix?: string;
        targets?: Record<string, TargetDefinition | undefined>;
        [key: string]: unknown;
    }): ProjectDefinition;
    // (undocumented)
    set(name: string, value: ProjectDefinition): this;
}

// @public (undocumented)
interface PromptDefinition {
    // (undocumented)
    default?: string | string[] | number | boolean | null;
    // (undocumented)
    id: string;
    // (undocumented)
    items?: Array<string | {
        value: JsonValue;
        label: string;
    }>;
    // (undocumented)
    message: string;
    // (undocumented)
    multiselect?: boolean;
    // (undocumented)
    propertyTypes: Set<string>;
    // (undocumented)
    raw?: string | JsonObject;
    // (undocumented)
    type: string;
    // (undocumented)
    validator?: (value: JsonValue) => boolean | string | Promise<boolean | string>;
}

// @public (undocumented)
type PromptProvider = (definitions: Array<PromptDefinition>) => ObservableInput<{
    [id: string]: JsonValue;
}>;

// @public (undocumented)
interface ReadonlyHost<StatsT extends object = {}> {
    // (undocumented)
    readonly capabilities: HostCapabilities;
    // (undocumented)
    exists(path: Path): Observable<boolean>;
    // (undocumented)
    isDirectory(path: Path): Observable<boolean>;
    // (undocumented)
    isFile(path: Path): Observable<boolean>;
    // (undocumented)
    list(path: Path): Observable<PathFragment[]>;
    // (undocumented)
    read(path: Path): Observable<FileBuffer>;
    // (undocumented)
    stat(path: Path): Observable<Stats<StatsT> | null> | null;
}

// @public
function readWorkspace(path: string, host: WorkspaceHost, format?: WorkspaceFormat): Promise<{
    workspace: WorkspaceDefinition;
}>;

// @public (undocumented)
interface ReferenceResolver<ContextT> {
    // (undocumented)
    (ref: string, context?: ContextT): {
        context?: ContextT;
        schema?: JsonObject;
    };
}

// @public
export function relative(from: Path, to: Path): Path;

// @public (undocumented)
type ReplacementFunction = (path: Path) => Path;

// @public
export function resetNormalizeCache(): void;

// @public
export function resolve(p1: Path, p2: Path): Path;

// @public
abstract class ResolverHost<T extends object> implements Host<T> {
    constructor(_delegate: Host<T>);
    // (undocumented)
    get capabilities(): HostCapabilities;
    // (undocumented)
    protected _delegate: Host<T>;
    // (undocumented)
    delete(path: Path): Observable<void>;
    // (undocumented)
    exists(path: Path): Observable<boolean>;
    // (undocumented)
    isDirectory(path: Path): Observable<boolean>;
    // (undocumented)
    isFile(path: Path): Observable<boolean>;
    // (undocumented)
    list(path: Path): Observable<PathFragment[]>;
    // (undocumented)
    read(path: Path): Observable<FileBuffer>;
    // (undocumented)
    rename(from: Path, to: Path): Observable<void>;
    // (undocumented)
    protected abstract _resolve(path: Path): Path;
    // (undocumented)
    stat(path: Path): Observable<Stats<T> | null> | null;
    // (undocumented)
    watch(path: Path, options?: HostWatchOptions): Observable<HostWatchEvent> | null;
    // (undocumented)
    write(path: Path, content: FileBuffer): Observable<void>;
}

// @public
class SafeReadonlyHost<StatsT extends object = {}> implements ReadonlyHost<StatsT> {
    constructor(_delegate: ReadonlyHost<StatsT>);
    // (undocumented)
    get capabilities(): HostCapabilities;
    // (undocumented)
    exists(path: Path): Observable<boolean>;
    // (undocumented)
    isDirectory(path: Path): Observable<boolean>;
    // (undocumented)
    isFile(path: Path): Observable<boolean>;
    // (undocumented)
    list(path: Path): Observable<PathFragment[]>;
    // (undocumented)
    read(path: Path): Observable<FileBuffer>;
    // (undocumented)
    stat(path: Path): Observable<Stats<StatsT> | null> | null;
}

declare namespace schema {
    export {
        transforms,
        JsonPointer,
        SchemaValidatorResult,
        SchemaValidatorError,
        SchemaValidatorOptions,
        SchemaValidator,
        SchemaFormatter,
        SchemaFormat,
        SmartDefaultProvider,
        SchemaKeywordValidator,
        PromptDefinition,
        PromptProvider,
        SchemaRegistry,
        JsonSchemaVisitor,
        JsonVisitor,
        buildJsonPointer,
        joinJsonPointer,
        parseJsonPointer,
        UriHandler,
        SchemaValidationException,
        CoreSchemaRegistry,
        isJsonSchema,
        mergeSchemas,
        JsonSchema,
        visitJson,
        visitJsonSchema,
        ReferenceResolver,
        getTypesOfSchema
    }
}
export { schema }

// @public (undocumented)
interface SchemaFormat {
    // (undocumented)
    formatter: SchemaFormatter;
    // (undocumented)
    name: string;
}

// @public (undocumented)
type SchemaFormatter = Format;

// @public (undocumented)
interface SchemaKeywordValidator {
    // (undocumented)
    (data: JsonValue, schema: JsonValue, parent: JsonObject | JsonArray | undefined, parentProperty: string | number | undefined, pointer: JsonPointer, rootData: JsonValue): boolean | Observable<boolean>;
}

// @public (undocumented)
interface SchemaRegistry {
    // (undocumented)
    addFormat(format: SchemaFormat): void;
    addPostTransform(visitor: JsonVisitor, deps?: JsonVisitor[]): void;
    addPreTransform(visitor: JsonVisitor, deps?: JsonVisitor[]): void;
    // (undocumented)
    addSmartDefaultProvider<T>(source: string, provider: SmartDefaultProvider<T>): void;
    // (undocumented)
    compile(schema: Object): Promise<SchemaValidator>;
    // (undocumented)
    usePromptProvider(provider: PromptProvider): void;
    // (undocumented)
    useXDeprecatedProvider(onUsage: (message: string) => void): void;
    // (undocumented)
    Éµflatten(schema: JsonObject | string): Promise<JsonObject>;
}

// @public (undocumented)
class SchemaValidationException extends BaseException {
    constructor(errors?: SchemaValidatorError[], baseMessage?: string);
    // (undocumented)
    static createMessages(errors?: SchemaValidatorError[]): string[];
    // (undocumented)
    readonly errors: SchemaValidatorError[];
}

// @public (undocumented)
interface SchemaValidator {
    // (undocumented)
    (data: JsonValue, options?: SchemaValidatorOptions): Promise<SchemaValidatorResult>;
}

// @public (undocumented)
type SchemaValidatorError = Partial<ErrorObject>;

// @public (undocumented)
interface SchemaValidatorOptions {
    // (undocumented)
    applyPostTransforms?: boolean;
    // (undocumented)
    applyPreTransforms?: boolean;
    // (undocumented)
    withPrompts?: boolean;
}

// @public (undocumented)
interface SchemaValidatorResult {
    // (undocumented)
    data: JsonValue;
    // (undocumented)
    errors?: SchemaValidatorError[];
    // (undocumented)
    success: boolean;
}

// @public (undocumented)
class ScopedHost<T extends object> extends ResolverHost<T> {
    constructor(delegate: Host<T>, _root?: Path);
    // (undocumented)
    protected _resolve(path: Path): Path;
    // (undocumented)
    protected _root: Path;
}

// @public (undocumented)
class SimpleMemoryHost implements Host<{}> {
    constructor();
    // (undocumented)
    protected _cache: Map<Path, Stats<SimpleMemoryHostStats>>;
    // (undocumented)
    get capabilities(): HostCapabilities;
    // (undocumented)
    delete(path: Path): Observable<void>;
    // (undocumented)
    protected _delete(path: Path): void;
    // (undocumented)
    exists(path: Path): Observable<boolean>;
    // (undocumented)
    protected _exists(path: Path): boolean;
    // (undocumented)
    isDirectory(path: Path): Observable<boolean>;
    // (undocumented)
    protected _isDirectory(path: Path): boolean;
    // (undocumented)
    isFile(path: Path): Observable<boolean>;
    // (undocumented)
    protected _isFile(path: Path): boolean;
    // (undocumented)
    list(path: Path): Observable<PathFragment[]>;
    // (undocumented)
    protected _list(path: Path): PathFragment[];
    // (undocumented)
    protected _newDirStats(): {
        inspect(): string;
        isFile(): boolean;
        isDirectory(): boolean;
        size: number;
        atime: Date;
        ctime: Date;
        mtime: Date;
        birthtime: Date;
        content: null;
    };
    // (undocumented)
    protected _newFileStats(content: FileBuffer, oldStats?: Stats<SimpleMemoryHostStats>): {
        inspect(): string;
        isFile(): boolean;
        isDirectory(): boolean;
        size: number;
        atime: Date;
        ctime: Date;
        mtime: Date;
        birthtime: Date;
        content: ArrayBuffer;
    };
    // (undocumented)
    read(path: Path): Observable<FileBuffer>;
    // (undocumented)
    protected _read(path: Path): FileBuffer;
    // (undocumented)
    rename(from: Path, to: Path): Observable<void>;
    // (undocumented)
    protected _rename(from: Path, to: Path): void;
    // (undocumented)
    reset(): void;
    // (undocumented)
    stat(path: Path): Observable<Stats<{}> | null> | null;
    // (undocumented)
    protected _stat(path: Path): Stats<SimpleMemoryHostStats> | null;
    // (undocumented)
    protected _toAbsolute(path: Path): Path;
    // (undocumented)
    protected _updateWatchers(path: Path, type: HostWatchEventType): void;
    // (undocumented)
    watch(path: Path, options?: HostWatchOptions): Observable<HostWatchEvent> | null;
    // (undocumented)
    protected _watch(path: Path, options?: HostWatchOptions): Observable<HostWatchEvent>;
    // (undocumented)
    write(path: Path, content: FileBuffer): Observable<void>;
    protected _write(path: Path, content: FileBuffer): void;
}

// @public (undocumented)
interface SimpleMemoryHostStats {
    // (undocumented)
    readonly content: FileBuffer | null;
}

// @public (undocumented)
interface SmartDefaultProvider<T> {
    // (undocumented)
    (schema: JsonObject): T | Observable<T>;
}

// @public
export function split(path: Path): PathFragment[];

// @public (undocumented)
type Stats<T extends object = {}> = T & {
    isFile(): boolean;
    isDirectory(): boolean;
    readonly size: number;
    readonly atime: Date;
    readonly mtime: Date;
    readonly ctime: Date;
    readonly birthtime: Date;
};

declare namespace strings {
    export {
        decamelize,
        dasherize,
        camelize,
        classify,
        underscore,
        capitalize,
        levenshtein
    }
}
export { strings }

// @public (undocumented)
function stringToFileBuffer(str: string): FileBuffer;

// @public (undocumented)
function stripIndent(strings: TemplateStringsArray, ...values: any[]): string;

// @public (undocumented)
function stripIndents(strings: TemplateStringsArray, ...values: any[]): string;

// @public
class SyncDelegateHost<T extends object = {}> {
    constructor(_delegate: Host<T>);
    // (undocumented)
    get capabilities(): HostCapabilities;
    // (undocumented)
    get delegate(): Host<T>;
    // (undocumented)
    protected _delegate: Host<T>;
    // (undocumented)
    delete(path: Path): void;
    // (undocumented)
    protected _doSyncCall<ResultT>(observable: Observable<ResultT>): ResultT;
    // (undocumented)
    exists(path: Path): boolean;
    // (undocumented)
    isDirectory(path: Path): boolean;
    // (undocumented)
    isFile(path: Path): boolean;
    // (undocumented)
    list(path: Path): PathFragment[];
    // (undocumented)
    read(path: Path): FileBuffer;
    // (undocumented)
    rename(from: Path, to: Path): void;
    // (undocumented)
    stat(path: Path): Stats<T> | null;
    // (undocumented)
    watch(path: Path, options?: HostWatchOptions): Observable<HostWatchEvent> | null;
    // (undocumented)
    write(path: Path, content: FileBufferLike): void;
}

// @public (undocumented)
interface SyncHostHandler<StatsT extends object = {}> {
    // (undocumented)
    delete(path: Path): void;
    // (undocumented)
    exists(path: Path): boolean;
    // (undocumented)
    isDirectory(path: Path): boolean;
    // (undocumented)
    isFile(path: Path): boolean;
    // (undocumented)
    list(path: Path): PathFragment[];
    // (undocumented)
    read(path: Path): FileBuffer;
    // (undocumented)
    rename(from: Path, to: Path): void;
    // (undocumented)
    stat(path: Path): Stats<StatsT> | null;
    // (undocumented)
    write(path: Path, content: FileBufferLike): void;
}

// @public (undocumented)
class SynchronousDelegateExpectedException extends BaseException {
    constructor();
}

declare namespace tags {
    export {
        oneLine,
        indentBy,
        stripIndent,
        stripIndents,
        trimNewlines,
        TemplateTag
    }
}
export { tags }

// @public (undocumented)
interface TargetDefinition {
    // (undocumented)
    builder: string;
    // (undocumented)
    configurations?: Record<string, Record<string, JsonValue | undefined> | undefined>;
    // (undocumented)
    defaultConfiguration?: string;
    // (undocumented)
    options?: Record<string, JsonValue | undefined>;
}

// @public (undocumented)
class TargetDefinitionCollection extends DefinitionCollection<TargetDefinition> {
    constructor(initial?: Record<string, TargetDefinition>, listener?: DefinitionCollectionListener<TargetDefinition>);
    // (undocumented)
    add(definition: {
        name: string;
    } & TargetDefinition): TargetDefinition;
    // (undocumented)
    set(name: string, value: TargetDefinition): this;
}

// @public
export function template<T>(content: string, options?: TemplateOptions): (input: T) => string;

// @public
export interface TemplateAst {
    // (undocumented)
    children: TemplateAstNode[];
    // (undocumented)
    content: string;
    // (undocumented)
    fileName: string;
}

// @public
export interface TemplateAstBase {
    // (undocumented)
    end: Position;
    // (undocumented)
    start: Position;
}

// @public
export interface TemplateAstComment extends TemplateAstBase {
    // (undocumented)
    kind: 'comment';
    // (undocumented)
    text: string;
}

// @public
export interface TemplateAstContent extends TemplateAstBase {
    // (undocumented)
    content: string;
    // (undocumented)
    kind: 'content';
}

// @public
export interface TemplateAstEscape extends TemplateAstBase {
    // (undocumented)
    expression: string;
    // (undocumented)
    kind: 'escape';
}

// @public
export interface TemplateAstEvaluate extends TemplateAstBase {
    // (undocumented)
    expression: string;
    // (undocumented)
    kind: 'evaluate';
}

// @public
export interface TemplateAstInterpolate extends TemplateAstBase {
    // (undocumented)
    expression: string;
    // (undocumented)
    kind: 'interpolate';
}

// @public (undocumented)
export type TemplateAstNode = TemplateAstContent | TemplateAstEvaluate | TemplateAstComment | TemplateAstEscape | TemplateAstInterpolate;

// @public (undocumented)
export interface TemplateOptions {
    // (undocumented)
    fileName?: string;
    // (undocumented)
    module?: boolean | {
        exports: {};
    };
    // (undocumented)
    sourceMap?: boolean;
    // (undocumented)
    sourceRoot?: string;
    // (undocumented)
    sourceURL?: string;
}

// @public
export function templateParser(sourceText: string, fileName: string): TemplateAst;

// @public
interface TemplateTag<R = string> {
    // (undocumented)
    (template: TemplateStringsArray, ...substitutions: any[]): R;
}

declare namespace test {
    export {
        TestLogRecord,
        TestHost
    }
}

// @public (undocumented)
class TestHost extends SimpleMemoryHost {
    // (undocumented)
    $exists(path: string): boolean;
    // (undocumented)
    $isDirectory(path: string): boolean;
    // (undocumented)
    $isFile(path: string): boolean;
    // (undocumented)
    $list(path: string): PathFragment[];
    // (undocumented)
    $read(path: string): string;
    // (undocumented)
    $write(path: string, content: string): void;
    constructor(map?: {
        [path: string]: string;
    });
    // (undocumented)
    clearRecords(): void;
    // (undocumented)
    clone(): TestHost;
    // (undocumented)
    protected _delete(path: Path): void;
    // (undocumented)
    protected _exists(path: Path): boolean;
    // (undocumented)
    get files(): Path[];
    // (undocumented)
    protected _isDirectory(path: Path): boolean;
    // (undocumented)
    protected _isFile(path: Path): boolean;
    // (undocumented)
    protected _list(path: Path): PathFragment[];
    // (undocumented)
    protected _read(path: Path): ArrayBuffer;
    // (undocumented)
    get records(): TestLogRecord[];
    // (undocumented)
    protected _records: TestLogRecord[];
    // (undocumented)
    protected _rename(from: Path, to: Path): void;
    // (undocumented)
    protected _stat(path: Path): Stats<SimpleMemoryHostStats> | null;
    // (undocumented)
    get sync(): SyncDelegateHost<{}>;
    // (undocumented)
    protected _sync: SyncDelegateHost<{}> | null;
    // (undocumented)
    protected _watch(path: Path, options?: HostWatchOptions): Observable<HostWatchEvent>;
    // (undocumented)
    protected _write(path: Path, content: FileBuffer): void;
}

// @public (undocumented)
type TestLogRecord = {
    kind: 'write' | 'read' | 'delete' | 'list' | 'exists' | 'isDirectory' | 'isFile' | 'stat' | 'watch';
    path: Path;
} | {
    kind: 'rename';
    from: Path;
    to: Path;
};

// @public (undocumented)
class TransformLogger extends Logger {
    constructor(name: string, transform: (stream: Observable<LogEntry>) => Observable<LogEntry>, parent?: Logger | null);
}

declare namespace transforms {
    export {
        addUndefinedDefaults
    }
}

// @public (undocumented)
function trimNewlines(strings: TemplateStringsArray, ...values: any[]): string;

// @public
function underscore(str: string): string;

// @public (undocumented)
export class UnknownException extends BaseException {
    constructor(message: string);
}

// @public (undocumented)
type UriHandler = (uri: string) => Observable<JsonObject> | Promise<JsonObject> | null | undefined;

declare namespace virtualFs {
    export {
        test,
        AliasHost,
        stringToFileBuffer,
        fileBufferToString,
        createSyncHost,
        SyncHostHandler,
        Empty,
        FileBuffer,
        FileBufferLike,
        HostWatchOptions,
        HostWatchEventType,
        Stats,
        HostWatchEvent,
        HostCapabilities,
        ReadonlyHost,
        Host,
        SimpleMemoryHostStats,
        SimpleMemoryHost,
        ReplacementFunction,
        PatternMatchingHost,
        CordHostCreate,
        CordHostOverwrite,
        CordHostRename,
        CordHostDelete,
        CordHostRecord,
        CordHost,
        SafeReadonlyHost,
        ScopedHost,
        SynchronousDelegateExpectedException,
        SyncDelegateHost,
        ResolverHost
    }
}
export { virtualFs }

// @public
function visitJson<ContextT>(json: JsonValue, visitor: JsonVisitor, schema?: JsonSchema, refResolver?: ReferenceResolver<ContextT>, context?: ContextT): Observable<JsonValue>;

// @public (undocumented)
function visitJsonSchema(schema: JsonSchema, visitor: JsonSchemaVisitor): void;

// @public (undocumented)
export type WindowsPath = string & {
    __PRIVATE_DEVKIT_WINDOWS_PATH: void;
};

// @public (undocumented)
interface WorkspaceDefinition {
    // (undocumented)
    readonly extensions: Record<string, JsonValue | undefined>;
    // (undocumented)
    readonly projects: ProjectDefinitionCollection;
}

// @public
enum WorkspaceFormat {
    // (undocumented)
    JSON = 0
}

// @public (undocumented)
interface WorkspaceHost {
    // (undocumented)
    isDirectory(path: string): Promise<boolean>;
    // (undocumented)
    isFile(path: string): Promise<boolean>;
    // (undocumented)
    readFile(path: string): Promise<string>;
    // (undocumented)
    writeFile(path: string, data: string): Promise<void>;
}

declare namespace workspaces {
    export {
        WorkspaceHost,
        createWorkspaceHost,
        WorkspaceFormat,
        readWorkspace,
        writeWorkspace,
        WorkspaceDefinition,
        ProjectDefinition,
        TargetDefinition,
        DefinitionCollectionListener,
        ProjectDefinitionCollection,
        TargetDefinitionCollection
    }
}
export { workspaces }

// @public
function writeWorkspace(workspace: WorkspaceDefinition, host: WorkspaceHost, path?: string, format?: WorkspaceFormat): Promise<void>;

// (No @packageDocumentation comment for this package)

```
