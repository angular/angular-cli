## API Report File for "@angular-devkit/core"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { ErrorObject } from 'ajv';
import { Format } from 'ajv';
import { Observable } from 'rxjs';
import { Observer } from 'rxjs';
import { Operator } from 'rxjs';
import { PartialObserver } from 'rxjs';
import { Position } from 'source-map';
import { Subject } from 'rxjs';
import { SubscribableOrPromise } from 'rxjs';
import { Subscription } from 'rxjs';
import { ValidateFunction } from 'ajv';

// @public (undocumented)
function addUndefinedDefaults(value: JsonValue, _pointer: JsonPointer, schema?: JsonSchema): JsonValue;

// @public
class AliasHost<StatsT extends object = {}> extends ResolverHost<StatsT> {
    // (undocumented)
    get aliases(): Map<Path, Path>;
    // (undocumented)
    protected _aliases: Map<Path, Path>;
    // (undocumented)
    protected _resolve(path: Path): Path;
}

// @public
interface Analytics {
    // (undocumented)
    event(category: string, action: string, options?: EventOptions): void;
    // (undocumented)
    flush(): Promise<void>;
    // (undocumented)
    pageview(path: string, options?: PageviewOptions): void;
    // (undocumented)
    screenview(screenName: string, appName: string, options?: ScreenviewOptions): void;
    // (undocumented)
    timing(category: string, variable: string, time: string | number, options?: TimingOptions): void;
}

declare namespace analytics {
    export {
        NgCliAnalyticsDimensions,
        NgCliAnalyticsMetrics,
        NgCliAnalyticsDimensionsFlagInfo,
        NgCliAnalyticsMetricsFlagInfo,
        CustomDimensionsAndMetricsOptions,
        EventOptions,
        ScreenviewOptions,
        PageviewOptions,
        TimingOptions,
        Analytics,
        AnalyticsReportKind,
        AnalyticsReportBase,
        AnalyticsReportEvent,
        AnalyticsReportScreenview,
        AnalyticsReportPageview,
        AnalyticsReportTiming,
        AnalyticsReport,
        AnalyticsForwarderFn,
        ForwardingAnalytics,
        AnalyticsReporter,
        LoggingAnalytics,
        MultiAnalytics,
        NoopAnalytics
    }
}
export { analytics }

// @public
type AnalyticsForwarderFn = (report: JsonObject & AnalyticsReport) => void;

// @public (undocumented)
type AnalyticsReport = AnalyticsReportEvent | AnalyticsReportScreenview | AnalyticsReportPageview | AnalyticsReportTiming;

// @public (undocumented)
interface AnalyticsReportBase extends JsonObject {
    // (undocumented)
    kind: AnalyticsReportKind;
}

// @public (undocumented)
class AnalyticsReporter {
    constructor(_analytics: Analytics);
    // (undocumented)
    protected _analytics: Analytics;
    // (undocumented)
    report(report: AnalyticsReport): void;
}

// @public (undocumented)
interface AnalyticsReportEvent extends AnalyticsReportBase {
    // (undocumented)
    action: string;
    // (undocumented)
    category: string;
    // (undocumented)
    kind: AnalyticsReportKind.Event;
    // (undocumented)
    options: JsonObject & EventOptions;
}

// @public (undocumented)
enum AnalyticsReportKind {
    // (undocumented)
    Event = "event",
    // (undocumented)
    Pageview = "pageview",
    // (undocumented)
    Screenview = "screenview",
    // (undocumented)
    Timing = "timing"
}

// @public (undocumented)
interface AnalyticsReportPageview extends AnalyticsReportBase {
    // (undocumented)
    kind: AnalyticsReportKind.Pageview;
    // (undocumented)
    options: JsonObject & PageviewOptions;
    // (undocumented)
    path: string;
}

// @public (undocumented)
interface AnalyticsReportScreenview extends AnalyticsReportBase {
    // (undocumented)
    appName: string;
    // (undocumented)
    kind: AnalyticsReportKind.Screenview;
    // (undocumented)
    options: JsonObject & ScreenviewOptions;
    // (undocumented)
    screenName: string;
}

// @public (undocumented)
interface AnalyticsReportTiming extends AnalyticsReportBase {
    // (undocumented)
    category: string;
    // (undocumented)
    kind: AnalyticsReportKind.Timing;
    // (undocumented)
    options: JsonObject & TimingOptions;
    // (undocumented)
    time: string | number;
    // (undocumented)
    variable: string;
}

// @public (undocumented)
export function asPosixPath(path: Path): PosixPath;

// @public (undocumented)
export function asWindowsPath(path: Path): WindowsPath;

// @public
export class BaseException extends Error {
    constructor(message?: string);
}

// @public
export function basename(path: Path): PathFragment;

// @public (undocumented)
function buildJsonPointer(fragments: string[]): JsonPointer;

// @public
function camelize(str: string): string;

// @public
function capitalize(str: string): string;

// @public (undocumented)
class ChannelAlreadyExistException extends BaseException {
    constructor(name: string);
}

// @public (undocumented)
export class CircularDependencyFoundException extends BaseException {
    constructor();
}

// @public
function classify(str: string): string;

// @public @deprecated (undocumented)
export function clean<T>(array: Array<T | undefined>): Array<T>;

// @public (undocumented)
export class ContentHasMutatedException extends BaseException {
    constructor(path: string);
}

// @public
class CordHost extends SimpleMemoryHost {
    constructor(_back: ReadonlyHost);
    // (undocumented)
    protected _back: ReadonlyHost;
    // (undocumented)
    get backend(): ReadonlyHost;
    // (undocumented)
    get capabilities(): HostCapabilities;
    clone(): CordHost;
    commit(host: Host, force?: boolean): Observable<void>;
    create(path: Path, content: FileBuffer): Observable<void>;
    // (undocumented)
    delete(path: Path): Observable<void>;
    // (undocumented)
    exists(path: Path): Observable<boolean>;
    // (undocumented)
    protected _filesToCreate: Set<Path>;
    // (undocumented)
    protected _filesToDelete: Set<Path>;
    // (undocumented)
    protected _filesToOverwrite: Set<Path>;
    // (undocumented)
    protected _filesToRename: Map<Path, Path>;
    // (undocumented)
    protected _filesToRenameRevert: Map<Path, Path>;
    // (undocumented)
    isDirectory(path: Path): Observable<boolean>;
    // (undocumented)
    isFile(path: Path): Observable<boolean>;
    // (undocumented)
    list(path: Path): Observable<PathFragment[]>;
    // (undocumented)
    overwrite(path: Path, content: FileBuffer): Observable<void>;
    // (undocumented)
    read(path: Path): Observable<FileBuffer>;
    // (undocumented)
    records(): CordHostRecord[];
    // (undocumented)
    rename(from: Path, to: Path): Observable<void>;
    // (undocumented)
    stat(path: Path): Observable<Stats | null> | null;
    // (undocumented)
    watch(path: Path, options?: HostWatchOptions): null;
    // (undocumented)
    willCreate(path: Path): boolean;
    // (undocumented)
    willDelete(path: Path): boolean;
    // (undocumented)
    willOverwrite(path: Path): boolean;
    // (undocumented)
    willRename(path: Path): boolean;
    // (undocumented)
    willRenameTo(path: Path, to: Path): boolean;
    // (undocumented)
    write(path: Path, content: FileBuffer): Observable<void>;
}

// @public (undocumented)
interface CordHostCreate {
    // (undocumented)
    content: FileBuffer;
    // (undocumented)
    kind: 'create';
    // (undocumented)
    path: Path;
}

// @public (undocumented)
interface CordHostDelete {
    // (undocumented)
    kind: 'delete';
    // (undocumented)
    path: Path;
}

// @public (undocumented)
interface CordHostOverwrite {
    // (undocumented)
    content: FileBuffer;
    // (undocumented)
    kind: 'overwrite';
    // (undocumented)
    path: Path;
}

// @public (undocumented)
type CordHostRecord = CordHostCreate | CordHostOverwrite | CordHostRename | CordHostDelete;

// @public (undocumented)
interface CordHostRename {
    // (undocumented)
    from: Path;
    // (undocumented)
    kind: 'rename';
    // (undocumented)
    to: Path;
}

// @public (undocumented)
class CoreSchemaRegistry implements SchemaRegistry {
    constructor(formats?: SchemaFormat[]);
    // (undocumented)
    addFormat(format: SchemaFormat): void;
    addPostTransform(visitor: JsonVisitor, deps?: JsonVisitor[]): void;
    addPreTransform(visitor: JsonVisitor, deps?: JsonVisitor[]): void;
    // (undocumented)
    addSmartDefaultProvider<T>(source: string, provider: SmartDefaultProvider<T>): void;
    compile(schema: JsonSchema): Observable<SchemaValidator>;
    // @deprecated
    flatten(schema: JsonObject): Observable<JsonObject>;
    // (undocumented)
    registerUriHandler(handler: UriHandler): void;
    // (undocumented)
    protected _resolver(ref: string, validate?: ValidateFunction): {
        context?: ValidateFunction;
        schema?: JsonObject;
    };
    // (undocumented)
    usePromptProvider(provider: PromptProvider): void;
    // (undocumented)
    useXDeprecatedProvider(onUsage: (message: string) => void): void;
}

// @public
function createDispatcher<A extends JsonValue, I extends JsonValue, O extends JsonValue>(options?: Partial<Readwrite<JobDescription>>): JobDispatcher<A, I, O>;

// @public
function createJobFactory<A extends JsonValue, I extends JsonValue, O extends JsonValue>(loader: () => Promise<JobHandler<A, I, O>>, options?: Partial<JobDescription>): JobHandler<A, I, O>;

// @public
function createJobHandler<A extends JsonValue, I extends JsonValue, O extends JsonValue>(fn: SimpleJobHandlerFn<A, I, O>, options?: Partial<JobDescription>): JobHandler<A, I, O>;

// @public
function createLoggerJob<A extends JsonValue, I extends JsonValue, O extends JsonValue>(job: JobHandler<A, I, O>, logger: LoggerApi): JobHandler<A, I, O>;

// @public (undocumented)
function createSyncHost<StatsT extends object = {}>(handler: SyncHostHandler<StatsT>): Host<StatsT>;

// @public (undocumented)
function createWorkspaceHost(host: virtualFs.Host): WorkspaceHost;

// @public
interface CustomDimensionsAndMetricsOptions {
    // (undocumented)
    dimensions?: (boolean | number | string)[];
    // (undocumented)
    metrics?: (boolean | number | string)[];
}

// @public
function dasherize(str: string): string;

// @public
function decamelize(str: string): string;

// @public (undocumented)
export function deepCopy<T>(value: T): T;

// @public (undocumented)
export type DeepReadonly<T> = T extends (infer R)[] ? DeepReadonlyArray<R> : T extends Function ? T : T extends object ? DeepReadonlyObject<T> : T;

// @public (undocumented)
export interface DeepReadonlyArray<T> extends Array<DeepReadonly<T>> {
}

// @public (undocumented)
export type DeepReadonlyObject<T> = {
    readonly [P in keyof T]: DeepReadonly<T[P]>;
};

// @public (undocumented)
type DefinitionCollectionListener<V extends object> = (name: string, action: 'add' | 'remove' | 'replace', newValue: V | undefined, oldValue: V | undefined, collection: DefinitionCollection<V>) => void;

// @public (undocumented)
export class DependencyNotFoundException extends BaseException {
    constructor();
}

// @public
export function dirname(path: Path): Path;

// @public (undocumented)
class Empty implements ReadonlyHost {
    // (undocumented)
    readonly capabilities: HostCapabilities;
    // (undocumented)
    exists(path: Path): Observable<boolean>;
    // (undocumented)
    isDirectory(path: Path): Observable<boolean>;
    // (undocumented)
    isFile(path: Path): Observable<boolean>;
    // (undocumented)
    list(path: Path): Observable<PathFragment[]>;
    // (undocumented)
    read(path: Path): Observable<FileBuffer>;
    // (undocumented)
    stat(path: Path): Observable<Stats<{}> | null>;
}

// @public (undocumented)
interface EventOptions extends CustomDimensionsAndMetricsOptions {
    // (undocumented)
    label?: string;
    // (undocumented)
    value?: string;
}

declare namespace experimental {
    export {
        jobs
    }
}
export { experimental }

// @public (undocumented)
export function extname(path: Path): string;

// @public
class FallbackRegistry<MinimumArgumentValueT extends JsonValue = JsonValue, MinimumInputValueT extends JsonValue = JsonValue, MinimumOutputValueT extends JsonValue = JsonValue> implements Registry<MinimumArgumentValueT, MinimumInputValueT, MinimumOutputValueT> {
    constructor(_fallbacks?: Registry<MinimumArgumentValueT, MinimumInputValueT, MinimumOutputValueT>[]);
    // (undocumented)
    addFallback(registry: Registry): void;
    // (undocumented)
    protected _fallbacks: Registry<MinimumArgumentValueT, MinimumInputValueT, MinimumOutputValueT>[];
    // (undocumented)
    get<A extends MinimumArgumentValueT = MinimumArgumentValueT, I extends MinimumInputValueT = MinimumInputValueT, O extends MinimumOutputValueT = MinimumOutputValueT>(name: JobName): Observable<JobHandler<A, I, O> | null>;
}

// @public (undocumented)
export class FileAlreadyExistException extends BaseException {
    constructor(path: string);
}

// @public (undocumented)
type FileBuffer = ArrayBuffer;

// @public (undocumented)
const fileBuffer: TemplateTag<FileBuffer>;

// @public (undocumented)
type FileBufferLike = ArrayBufferLike;

// @public (undocumented)
function fileBufferToString(fileBuffer: FileBuffer): string;

// @public (undocumented)
export class FileDoesNotExistException extends BaseException {
    constructor(path: string);
}

// @public
class ForwardingAnalytics implements Analytics {
    constructor(_fn: AnalyticsForwarderFn);
    // (undocumented)
    event(category: string, action: string, options?: EventOptions): void;
    // (undocumented)
    flush(): Promise<void>;
    // (undocumented)
    protected _fn: AnalyticsForwarderFn;
    // (undocumented)
    pageview(path: string, options?: PageviewOptions): void;
    // (undocumented)
    screenview(screenName: string, appName: string, options?: ScreenviewOptions): void;
    // (undocumented)
    timing(category: string, variable: string, time: string | number, options?: TimingOptions): void;
}

// @public (undocumented)
export function fragment(path: string): PathFragment;

// @public (undocumented)
export function getSystemPath(path: Path): string;

// @public (undocumented)
function getTypesOfSchema(schema: JsonSchema): Set<string>;

// @public (undocumented)
interface Host<StatsT extends object = {}> extends ReadonlyHost<StatsT> {
    // (undocumented)
    delete(path: Path): Observable<void>;
    // (undocumented)
    rename(from: Path, to: Path): Observable<void>;
    // (undocumented)
    watch(path: Path, options?: HostWatchOptions): Observable<HostWatchEvent> | null;
    // (undocumented)
    write(path: Path, content: FileBufferLike): Observable<void>;
}

// @public (undocumented)
interface HostCapabilities {
    // (undocumented)
    synchronous: boolean;
}

// @public (undocumented)
interface HostWatchEvent {
    // (undocumented)
    readonly path: Path;
    // (undocumented)
    readonly time: Date;
    // (undocumented)
    readonly type: HostWatchEventType;
}

// @public (undocumented)
const enum HostWatchEventType {
    // (undocumented)
    Changed = 0,
    // (undocumented)
    Created = 1,
    // (undocumented)
    Deleted = 2,
    // (undocumented)
    Renamed = 3
}

// @public (undocumented)
interface HostWatchOptions {
    // (undocumented)
    readonly persistent?: boolean;
    // (undocumented)
    readonly recursive?: boolean;
}

// @public (undocumented)
function indentBy(indentations: number): TemplateTag;

// @public (undocumented)
class IndentLogger extends Logger {
    constructor(name: string, parent?: Logger | null, indentation?: string);
}

// @public (undocumented)
export class InvalidPathException extends BaseException {
    constructor(path: string);
}

// @public (undocumented)
export class InvalidUpdateRecordException extends BaseException {
    constructor();
}

// @public
export function isAbsolute(p: Path): boolean;

// @public (undocumented)
function isJobHandler<A extends JsonValue, I extends JsonValue, O extends JsonValue>(value: unknown): value is JobHandler<A, I, O>;

// @public (undocumented)
export function isJsonArray(value: JsonValue): value is JsonArray;

// @public (undocumented)
export function isJsonObject(value: JsonValue): value is JsonObject;

// @public (undocumented)
function isJsonSchema(value: unknown): value is JsonSchema;

// @public
export function isPromise(obj: any): obj is Promise<any>;

// @public
interface Job<ArgumentT extends JsonValue = JsonValue, InputT extends JsonValue = JsonValue, OutputT extends JsonValue = JsonValue> {
    readonly argument: ArgumentT;
    readonly description: Observable<JobDescription>;
    getChannel<T extends JsonValue>(name: string, schema?: schema.JsonSchema): Observable<T>;
    readonly inboundBus: Observer<JobInboundMessage<InputT>>;
    readonly input: Observer<InputT>;
    readonly outboundBus: Observable<JobOutboundMessage<OutputT>>;
    readonly output: Observable<OutputT>;
    ping(): Observable<never>;
    readonly state: JobState;
    stop(): void;
}

// @public (undocumented)
class JobArgumentSchemaValidationError extends schema.SchemaValidationException {
    constructor(errors?: schema.SchemaValidatorError[]);
}

// @public
interface JobDescription extends JsonObject {
    // (undocumented)
    readonly argument: DeepReadonly<schema.JsonSchema>;
    // (undocumented)
    readonly input: DeepReadonly<schema.JsonSchema>;
    // (undocumented)
    readonly name: JobName;
    // (undocumented)
    readonly output: DeepReadonly<schema.JsonSchema>;
}

// @public
interface JobDispatcher<A extends JsonValue, I extends JsonValue, O extends JsonValue> extends JobHandler<A, I, O> {
    addConditionalJob(predicate: (args: A) => boolean, name: string): void;
    setDefaultJob(name: JobName | null | JobHandler<JsonValue, JsonValue, JsonValue>): void;
}

// @public (undocumented)
class JobDoesNotExistException extends BaseException {
    constructor(name: JobName);
}

// @public
interface JobHandler<ArgT extends JsonValue, InputT extends JsonValue, OutputT extends JsonValue> {
    // (undocumented)
    (argument: ArgT, context: JobHandlerContext<ArgT, InputT, OutputT>): Observable<JobOutboundMessage<OutputT>>;
    // (undocumented)
    jobDescription: Partial<JobDescription>;
}

// @public
interface JobHandlerContext<MinimumArgumentValueT extends JsonValue = JsonValue, MinimumInputValueT extends JsonValue = JsonValue, MinimumOutputValueT extends JsonValue = JsonValue> {
    // (undocumented)
    readonly dependencies: Job<JsonValue, JsonValue, JsonValue>[];
    // (undocumented)
    readonly description: JobDescription;
    // (undocumented)
    readonly inboundBus: Observable<JobInboundMessage<MinimumInputValueT>>;
    // (undocumented)
    readonly scheduler: Scheduler<JsonValue, JsonValue, JsonValue>;
}

// @public (undocumented)
type JobInboundMessage<InputT extends JsonValue> = JobInboundMessagePing | JobInboundMessageStop | JobInboundMessageInput<InputT>;

// @public
interface JobInboundMessageBase extends JsonObject {
    readonly kind: JobInboundMessageKind;
}

// @public
interface JobInboundMessageInput<InputT extends JsonValue> extends JobInboundMessageBase {
    // (undocumented)
    readonly kind: JobInboundMessageKind.Input;
    readonly value: InputT;
}

// @public
enum JobInboundMessageKind {
    // (undocumented)
    Input = "in",
    // (undocumented)
    Ping = "ip",
    // (undocumented)
    Stop = "is"
}

// @public
interface JobInboundMessagePing extends JobInboundMessageBase {
    readonly id: number;
    // (undocumented)
    readonly kind: JobInboundMessageKind.Ping;
}

// @public (undocumented)
class JobInboundMessageSchemaValidationError extends schema.SchemaValidationException {
    constructor(errors?: schema.SchemaValidatorError[]);
}

// @public
interface JobInboundMessageStop extends JobInboundMessageBase {
    // (undocumented)
    readonly kind: JobInboundMessageKind.Stop;
}

// @public
type JobName = string;

// @public (undocumented)
class JobNameAlreadyRegisteredException extends BaseException {
    constructor(name: JobName);
}

// @public
type JobOutboundMessage<OutputT extends JsonValue> = JobOutboundMessageOnReady | JobOutboundMessageStart | JobOutboundMessageOutput<OutputT> | JobOutboundMessageChannelCreate | JobOutboundMessageChannelMessage | JobOutboundMessageChannelError | JobOutboundMessageChannelComplete | JobOutboundMessageEnd | JobOutboundMessagePong;

// @public
interface JobOutboundMessageBase {
    readonly description: JobDescription;
    readonly kind: JobOutboundMessageKind;
}

// @public
interface JobOutboundMessageChannelBase extends JobOutboundMessageBase {
    readonly name: string;
}

// @public
interface JobOutboundMessageChannelComplete extends JobOutboundMessageChannelBase {
    // (undocumented)
    readonly kind: JobOutboundMessageKind.ChannelComplete;
}

// @public
interface JobOutboundMessageChannelCreate extends JobOutboundMessageChannelBase {
    // (undocumented)
    readonly kind: JobOutboundMessageKind.ChannelCreate;
}

// @public
interface JobOutboundMessageChannelError extends JobOutboundMessageChannelBase {
    readonly error: JsonValue;
    // (undocumented)
    readonly kind: JobOutboundMessageKind.ChannelError;
}

// @public
interface JobOutboundMessageChannelMessage extends JobOutboundMessageChannelBase {
    // (undocumented)
    readonly kind: JobOutboundMessageKind.ChannelMessage;
    readonly message: JsonValue;
}

// @public
interface JobOutboundMessageEnd extends JobOutboundMessageBase {
    // (undocumented)
    readonly kind: JobOutboundMessageKind.End;
}

// @public
enum JobOutboundMessageKind {
    // (undocumented)
    ChannelComplete = "cc",
    // (undocumented)
    ChannelCreate = "cn",
    // (undocumented)
    ChannelError = "ce",
    // (undocumented)
    ChannelMessage = "cm",
    // (undocumented)
    End = "e",
    // (undocumented)
    OnReady = "c",
    // (undocumented)
    Output = "o",
    // (undocumented)
    Pong = "p",
    // (undocumented)
    Start = "s"
}

// @public
interface JobOutboundMessageOnReady extends JobOutboundMessageBase {
    // (undocumented)
    readonly kind: JobOutboundMessageKind.OnReady;
}

// @public
interface JobOutboundMessageOutput<OutputT extends JsonValue> extends JobOutboundMessageBase {
    // (undocumented)
    readonly kind: JobOutboundMessageKind.Output;
    readonly value: OutputT;
}

// @public
interface JobOutboundMessagePong extends JobOutboundMessageBase {
    readonly id: number;
    // (undocumented)
    readonly kind: JobOutboundMessageKind.Pong;
}

// @public
interface JobOutboundMessageStart extends JobOutboundMessageBase {
    // (undocumented)
    readonly kind: JobOutboundMessageKind.Start;
}

// @public (undocumented)
class JobOutputSchemaValidationError extends schema.SchemaValidationException {
    constructor(errors?: schema.SchemaValidatorError[]);
}

declare namespace jobs {
    export {
        isJobHandler,
        JobName,
        JobHandler,
        JobHandlerContext,
        JobDescription,
        JobInboundMessageKind,
        JobInboundMessageBase,
        JobInboundMessagePing,
        JobInboundMessageStop,
        JobInboundMessageInput,
        JobInboundMessage,
        JobOutboundMessageKind,
        JobOutboundMessageBase,
        JobOutboundMessageOnReady,
        JobOutboundMessageStart,
        JobOutboundMessageOutput,
        JobOutboundMessageChannelBase,
        JobOutboundMessageChannelMessage,
        JobOutboundMessageChannelError,
        JobOutboundMessageChannelCreate,
        JobOutboundMessageChannelComplete,
        JobOutboundMessageEnd,
        JobOutboundMessagePong,
        JobOutboundMessage,
        JobState,
        Job,
        ScheduleJobOptions,
        Registry,
        Scheduler,
        createJobHandler,
        createJobFactory,
        createLoggerJob,
        ChannelAlreadyExistException,
        SimpleJobHandlerContext,
        SimpleJobHandlerFn,
        JobNameAlreadyRegisteredException,
        JobDoesNotExistException,
        createDispatcher,
        JobDispatcher,
        FallbackRegistry,
        RegisterJobOptions,
        SimpleJobRegistry,
        JobArgumentSchemaValidationError,
        JobInboundMessageSchemaValidationError,
        JobOutputSchemaValidationError,
        SimpleScheduler,
        strategy
    }
}

// @public
enum JobState {
    Ended = "ended",
    Errored = "errored",
    Queued = "queued",
    Ready = "ready",
    Started = "started"
}

// @public
export function join(p1: Path, ...others: string[]): Path;

// @public (undocumented)
function joinJsonPointer(root: JsonPointer, ...others: string[]): JsonPointer;

declare namespace json {
    export {
        schema,
        isJsonObject,
        isJsonArray,
        JsonArray,
        JsonObject,
        JsonValue
    }
}
export { json }

// @public
export interface JsonArray extends Array<JsonValue> {
}

// @public (undocumented)
export interface JsonObject {
    // (undocumented)
    [prop: string]: JsonValue;
}

// @public (undocumented)
type JsonPointer = string & {
    __PRIVATE_DEVKIT_JSON_POINTER: void;
};

// @public
type JsonSchema = JsonObject | boolean;

// @public (undocumented)
interface JsonSchemaVisitor {
    // (undocumented)
    (current: JsonObject | JsonArray, pointer: JsonPointer, parentSchema?: JsonObject | JsonArray, index?: string): void;
}

// @public (undocumented)
export type JsonValue = boolean | string | number | JsonArray | JsonObject | null;

// @public (undocumented)
interface JsonVisitor {
    // (undocumented)
    (value: JsonValue, pointer: JsonPointer, schema?: JsonObject, root?: JsonObject | JsonArray): Observable<JsonValue> | JsonValue;
}

// @public (undocumented)
class LevelCapLogger extends LevelTransformLogger {
    constructor(name: string, parent: Logger | null, levelCap: LogLevel);
    // (undocumented)
    readonly levelCap: LogLevel;
    // (undocumented)
    static levelMap: {
        [cap: string]: {
            [level: string]: string;
        };
    };
    // (undocumented)
    readonly name: string;
    // (undocumented)
    readonly parent: Logger | null;
}

// @public (undocumented)
class LevelTransformLogger extends Logger {
    constructor(name: string, parent: Logger | null, levelTransform: (level: LogLevel) => LogLevel);
    // (undocumented)
    createChild(name: string): Logger;
    // (undocumented)
    readonly levelTransform: (level: LogLevel) => LogLevel;
    // (undocumented)
    log(level: LogLevel, message: string, metadata?: JsonObject): void;
    // (undocumented)
    readonly name: string;
    // (undocumented)
    readonly parent: Logger | null;
}

// @public
function levenshtein(a: string, b: string): number;

// @public (undocumented)
interface LogEntry extends LoggerMetadata {
    // (undocumented)
    level: LogLevel;
    // (undocumented)
    message: string;
    // (undocumented)
    timestamp: number;
}

// @public (undocumented)
class Logger extends Observable<LogEntry> implements LoggerApi {
    constructor(name: string, parent?: Logger | null);
    // (undocumented)
    asApi(): LoggerApi;
    // (undocumented)
    complete(): void;
    // (undocumented)
    createChild(name: string): Logger;
    // (undocumented)
    debug(message: string, metadata?: JsonObject): void;
    // (undocumented)
    error(message: string, metadata?: JsonObject): void;
    // (undocumented)
    fatal(message: string, metadata?: JsonObject): void;
    // (undocumented)
    forEach(next: (value: LogEntry) => void, PromiseCtor?: typeof Promise): Promise<void>;
    // (undocumented)
    info(message: string, metadata?: JsonObject): void;
    // (undocumented)
    lift<R>(operator: Operator<LogEntry, R>): Observable<R>;
    // (undocumented)
    log(level: LogLevel, message: string, metadata?: JsonObject): void;
    // (undocumented)
    protected _metadata: LoggerMetadata;
    // (undocumented)
    readonly name: string;
    // (undocumented)
    next(entry: LogEntry): void;
    // (undocumented)
    protected get _observable(): Observable<LogEntry>;
    protected set _observable(v: Observable<LogEntry>);
    // (undocumented)
    readonly parent: Logger | null;
    // (undocumented)
    protected readonly _subject: Subject<LogEntry>;
    // (undocumented)
    subscribe(): Subscription;
    // (undocumented)
    subscribe(observer: PartialObserver<LogEntry>): Subscription;
    // (undocumented)
    subscribe(next?: (value: LogEntry) => void, error?: (error: Error) => void, complete?: () => void): Subscription;
    // (undocumented)
    toString(): string;
    // (undocumented)
    warn(message: string, metadata?: JsonObject): void;
}

// @public (undocumented)
interface LoggerApi {
    // (undocumented)
    createChild(name: string): Logger;
    // (undocumented)
    debug(message: string, metadata?: JsonObject): void;
    // (undocumented)
    error(message: string, metadata?: JsonObject): void;
    // (undocumented)
    fatal(message: string, metadata?: JsonObject): void;
    // (undocumented)
    info(message: string, metadata?: JsonObject): void;
    // (undocumented)
    log(level: LogLevel, message: string, metadata?: JsonObject): void;
    // (undocumented)
    warn(message: string, metadata?: JsonObject): void;
}

// @public (undocumented)
interface LoggerMetadata extends JsonObject {
    // (undocumented)
    name: string;
    // (undocumented)
    path: string[];
}

declare namespace logging {
    export {
        IndentLogger,
        LevelTransformLogger,
        LevelCapLogger,
        LoggerMetadata,
        LogEntry,
        LoggerApi,
        LogLevel,
        Logger,
        NullLogger,
        TransformLogger
    }
}
export { logging }

// @public
class LoggingAnalytics implements Analytics {
    constructor(_logger: Logger);
    // (undocumented)
    event(category: string, action: string, options?: EventOptions): void;
    // (undocumented)
    flush(): Promise<void>;
    // (undocumented)
    protected _logger: Logger;
    // (undocumented)
    pageview(path: string, options?: PageviewOptions): void;
    // (undocumented)
    screenview(screenName: string, appName: string, options?: ScreenviewOptions): void;
    // (undocumented)
    timing(category: string, variable: string, time: string | number, options?: TimingOptions): void;
}

// @public (undocumented)
type LogLevel = 'debug' | 'info' | 'warn' | 'error' | 'fatal';

// @public @deprecated (undocumented)
export function mapObject<T, V>(obj: {
    [k: string]: T;
}, mapper: (k: string, v: T) => V): {
    [k: string]: V;
};

// @public (undocumented)
export class MergeConflictException extends BaseException {
    constructor(path: string);
}

// @public
function mergeSchemas(...schemas: (JsonSchema | undefined)[]): JsonSchema;

// @public
class MultiAnalytics implements Analytics {
    constructor(_backends?: Analytics[]);
    // (undocumented)
    protected _backends: Analytics[];
    // (undocumented)
    event(category: string, action: string, options?: EventOptions): void;
    // (undocumented)
    flush(): Promise<void>;
    // (undocumented)
    pageview(path: string, options?: PageviewOptions): void;
    // (undocumented)
    push(...backend: Analytics[]): void;
    // (undocumented)
    screenview(screenName: string, appName: string, options?: ScreenviewOptions): void;
    // (undocumented)
    timing(category: string, variable: string, time: string | number, options?: TimingOptions): void;
}

// @public
enum NgCliAnalyticsDimensions {
    // (undocumented)
    AotEnabled = 8,
    // (undocumented)
    BuildErrors = 20,
    // (undocumented)
    CpuCount = 1,
    // (undocumented)
    CpuSpeed = 2,
    // (undocumented)
    NgAddCollection = 6,
    // (undocumented)
    NodeVersion = 4,
    // (undocumented)
    RamInGigabytes = 3
}

// @public (undocumented)
const NgCliAnalyticsDimensionsFlagInfo: {
    [name: string]: [string, string];
};

// @public (undocumented)
enum NgCliAnalyticsMetrics {
    // (undocumented)
    AssetCount = 12,
    // (undocumented)
    AssetSize = 13,
    // (undocumented)
    BuildTime = 5,
    // (undocumented)
    CssSize = 15,
    // (undocumented)
    InitialChunkSize = 7,
    // (undocumented)
    LazyChunkCount = 10,
    // (undocumented)
    LazyChunkSize = 11,
    // (undocumented)
    NgComponentCount = 1,
    // (undocumented)
    NgOnInitCount = 6,
    // (undocumented)
    PolyfillSize = 14,
    // (undocumented)
    TotalChunkCount = 8,
    // (undocumented)
    TotalChunkSize = 9,
    // (undocumented)
    UNUSED_2 = 2,
    // (undocumented)
    UNUSED_3 = 3,
    // (undocumented)
    UNUSED_4 = 4
}

// @public (undocumented)
const NgCliAnalyticsMetricsFlagInfo: {
    [name: string]: [string, string];
};

// @public
export function noCacheNormalize(path: string): Path;

// @public
class NoopAnalytics implements Analytics {
    // (undocumented)
    event(): void;
    // (undocumented)
    flush(): Promise<void>;
    // (undocumented)
    pageview(): void;
    // (undocumented)
    screenview(): void;
    // (undocumented)
    timing(): void;
}

// @public
export function normalize(path: string): Path;

// @public
export const NormalizedRoot: Path;

// @public
export const NormalizedSep: Path;

// @public (undocumented)
class NullLogger extends Logger {
    constructor(parent?: Logger | null);
    // (undocumented)
    asApi(): LoggerApi;
}

// @public (undocumented)
function oneLine(strings: TemplateStringsArray, ...values: any[]): string;

// @public (undocumented)
interface PageviewOptions extends CustomDimensionsAndMetricsOptions {
    // (undocumented)
    hostname?: string;
    // (undocumented)
    title?: string;
}

// @public (undocumented)
function parseJsonPointer(pointer: JsonPointer): string[];

// @public (undocumented)
export class PartiallyOrderedSet<T> implements Set<T> {
    // (undocumented)
    [Symbol.iterator](): Generator<T, void, unknown>;
    // (undocumented)
    get [Symbol.toStringTag](): 'Set';
    // (undocumented)
    add(item: T, deps?: Set<T> | T[]): this;
    // (undocumented)
    protected _checkCircularDependencies(item: T, deps: Set<T>): void;
    // (undocumented)
    clear(): void;
    // (undocumented)
    delete(item: T): boolean;
    entries(): IterableIterator<[T, T]>;
    // (undocumented)
    forEach(callbackfn: (value: T, value2: T, set: PartiallyOrderedSet<T>) => void, thisArg?: any): void;
    // (undocumented)
    has(item: T): boolean;
    keys(): IterableIterator<T>;
    // (undocumented)
    get size(): number;
    values(): IterableIterator<T>;
}

// @public
export type Path = string & {
    __PRIVATE_DEVKIT_PATH: void;
};

// @public (undocumented)
export const path: TemplateTag<Path>;

// @public (undocumented)
export class PathCannotBeFragmentException extends BaseException {
    constructor(path: string);
}

// @public
export type PathFragment = Path & {
    __PRIVATE_DEVKIT_PATH_FRAGMENT: void;
};

// @public (undocumented)
export class PathIsDirectoryException extends BaseException {
    constructor(path: string);
}

// @public (undocumented)
export class PathIsFileException extends BaseException {
    constructor(path: string);
}

// @public (undocumented)
export class PathMustBeAbsoluteException extends BaseException {
    constructor(path: string);
}

// @public (undocumented)
class PatternMatchingHost<StatsT extends object = {}> extends ResolverHost<StatsT> {
    // (undocumented)
    addPattern(pattern: string | string[], replacementFn: ReplacementFunction): void;
    // (undocumented)
    protected _patterns: Map<RegExp, ReplacementFunction>;
    // (undocumented)
    protected _resolve(path: Path): Path;
}

// @public (undocumented)
export type PosixPath = string & {
    __PRIVATE_DEVKIT_POSIX_PATH: void;
};

// @public
export class PriorityQueue<T> {
    constructor(_comparator: (x: T, y: T) => number);
    // (undocumented)
    clear(): void;
    // (undocumented)
    peek(): T | undefined;
    // (undocumented)
    pop(): T | undefined;
    // (undocumented)
    push(item: T): void;
    // (undocumented)
    get size(): number;
    // (undocumented)
    toArray(): Array<T>;
}

// @public (undocumented)
interface ProjectDefinition {
    // (undocumented)
    readonly extensions: Record<string, JsonValue | undefined>;
    // (undocumented)
    prefix?: string;
    // (undocumented)
    root: string;
    // (undocumented)
    sourceRoot?: string;
    // (undocumented)
    readonly targets: TargetDefinitionCollection;
}

// @public (undocumented)
class ProjectDefinitionCollection extends DefinitionCollection<ProjectDefinition> {
    constructor(initial?: Record<string, ProjectDefinition>, listener?: DefinitionCollectionListener<ProjectDefinition>);
    // (undocumented)
    add(definition: {
        name: string;
        root: string;
        sourceRoot?: string;
        prefix?: string;
        targets?: Record<string, TargetDefinition | undefined>;
        [key: string]: unknown;
    }): ProjectDefinition;
    // (undocumented)
    set(name: string, value: ProjectDefinition): this;
}

// @public (undocumented)
interface PromptDefinition {
    // (undocumented)
    default?: string | string[] | number | boolean | null;
    // (undocumented)
    id: string;
    // (undocumented)
    items?: Array<string | {
        value: JsonValue;
        label: string;
    }>;
    // (undocumented)
    message: string;
    // (undocumented)
    multiselect?: boolean;
    // (undocumented)
    propertyTypes: Set<string>;
    // (undocumented)
    raw?: string | JsonObject;
    // (undocumented)
    type: string;
    // (undocumented)
    validator?: (value: JsonValue) => boolean | string | Promise<boolean | string>;
}

// @public (undocumented)
type PromptProvider = (definitions: Array<PromptDefinition>) => SubscribableOrPromise<{
    [id: string]: JsonValue;
}>;

// @public (undocumented)
interface ReadonlyHost<StatsT extends object = {}> {
    // (undocumented)
    readonly capabilities: HostCapabilities;
    // (undocumented)
    exists(path: Path): Observable<boolean>;
    // (undocumented)
    isDirectory(path: Path): Observable<boolean>;
    // (undocumented)
    isFile(path: Path): Observable<boolean>;
    // (undocumented)
    list(path: Path): Observable<PathFragment[]>;
    // (undocumented)
    read(path: Path): Observable<FileBuffer>;
    // (undocumented)
    stat(path: Path): Observable<Stats<StatsT> | null> | null;
}

// @public
function readWorkspace(path: string, host: WorkspaceHost, format?: WorkspaceFormat): Promise<{
    workspace: WorkspaceDefinition;
}>;

// @public (undocumented)
export type Readwrite<T> = {
    -readonly [P in keyof T]: T[P];
};

// @public (undocumented)
interface ReferenceResolver<ContextT> {
    // (undocumented)
    (ref: string, context?: ContextT): {
        context?: ContextT;
        schema?: JsonObject;
    };
}

// @public
interface RegisterJobOptions extends Partial<JobDescription> {
}

// @public (undocumented)
interface Registry<MinimumArgumentValueT extends JsonValue = JsonValue, MinimumInputValueT extends JsonValue = JsonValue, MinimumOutputValueT extends JsonValue = JsonValue> {
    get<A extends MinimumArgumentValueT, I extends MinimumInputValueT, O extends MinimumOutputValueT>(name: JobName): Observable<JobHandler<A, I, O> | null>;
}

// @public
export function relative(from: Path, to: Path): Path;

// @public (undocumented)
type ReplacementFunction = (path: Path) => Path;

// @public
export function resetNormalizeCache(): void;

// @public
export function resolve(p1: Path, p2: Path): Path;

// @public
abstract class ResolverHost<T extends object> implements Host<T> {
    constructor(_delegate: Host<T>);
    // (undocumented)
    get capabilities(): HostCapabilities;
    // (undocumented)
    protected _delegate: Host<T>;
    // (undocumented)
    delete(path: Path): Observable<void>;
    // (undocumented)
    exists(path: Path): Observable<boolean>;
    // (undocumented)
    isDirectory(path: Path): Observable<boolean>;
    // (undocumented)
    isFile(path: Path): Observable<boolean>;
    // (undocumented)
    list(path: Path): Observable<PathFragment[]>;
    // (undocumented)
    read(path: Path): Observable<FileBuffer>;
    // (undocumented)
    rename(from: Path, to: Path): Observable<void>;
    // (undocumented)
    protected abstract _resolve(path: Path): Path;
    // (undocumented)
    stat(path: Path): Observable<Stats<T> | null> | null;
    // (undocumented)
    watch(path: Path, options?: HostWatchOptions): Observable<HostWatchEvent> | null;
    // (undocumented)
    write(path: Path, content: FileBuffer): Observable<void>;
}

// @public
class SafeReadonlyHost<StatsT extends object = {}> implements ReadonlyHost<StatsT> {
    constructor(_delegate: ReadonlyHost<StatsT>);
    // (undocumented)
    get capabilities(): HostCapabilities;
    // (undocumented)
    exists(path: Path): Observable<boolean>;
    // (undocumented)
    isDirectory(path: Path): Observable<boolean>;
    // (undocumented)
    isFile(path: Path): Observable<boolean>;
    // (undocumented)
    list(path: Path): Observable<PathFragment[]>;
    // (undocumented)
    read(path: Path): Observable<FileBuffer>;
    // (undocumented)
    stat(path: Path): Observable<Stats<StatsT> | null> | null;
}

// @public
interface ScheduleJobOptions {
    dependencies?: Job | Job[];
}

// @public
interface Scheduler<MinimumArgumentValueT extends JsonValue = JsonValue, MinimumInputValueT extends JsonValue = JsonValue, MinimumOutputValueT extends JsonValue = JsonValue> {
    getDescription(name: JobName): Observable<JobDescription | null>;
    has(name: JobName): Observable<boolean>;
    pause(): () => void;
    schedule<A extends MinimumArgumentValueT, I extends MinimumInputValueT, O extends MinimumOutputValueT>(name: JobName, argument: A, options?: ScheduleJobOptions): Job<A, I, O>;
}

declare namespace schema {
    export {
        transforms,
        JsonPointer,
        SchemaValidatorResult,
        SchemaValidatorError,
        SchemaValidatorOptions,
        SchemaValidator,
        SchemaFormatter,
        SchemaFormat,
        SmartDefaultProvider,
        SchemaKeywordValidator,
        PromptDefinition,
        PromptProvider,
        SchemaRegistry,
        JsonSchemaVisitor,
        JsonVisitor,
        buildJsonPointer,
        joinJsonPointer,
        parseJsonPointer,
        UriHandler,
        SchemaValidationException,
        CoreSchemaRegistry,
        isJsonSchema,
        mergeSchemas,
        JsonSchema,
        visitJson,
        visitJsonSchema,
        ReferenceResolver,
        getTypesOfSchema
    }
}
export { schema }

// @public (undocumented)
interface SchemaFormat {
    // (undocumented)
    formatter: SchemaFormatter;
    // (undocumented)
    name: string;
}

// @public (undocumented)
type SchemaFormatter = Format;

// @public (undocumented)
interface SchemaKeywordValidator {
    // (undocumented)
    (data: JsonValue, schema: JsonValue, parent: JsonObject | JsonArray | undefined, parentProperty: string | number | undefined, pointer: JsonPointer, rootData: JsonValue): boolean | Observable<boolean>;
}

// @public (undocumented)
interface SchemaRegistry {
    // (undocumented)
    addFormat(format: SchemaFormat): void;
    addPostTransform(visitor: JsonVisitor, deps?: JsonVisitor[]): void;
    addPreTransform(visitor: JsonVisitor, deps?: JsonVisitor[]): void;
    // (undocumented)
    addSmartDefaultProvider<T>(source: string, provider: SmartDefaultProvider<T>): void;
    // (undocumented)
    compile(schema: Object): Observable<SchemaValidator>;
    // @deprecated (undocumented)
    flatten(schema: JsonObject | string): Observable<JsonObject>;
    // (undocumented)
    usePromptProvider(provider: PromptProvider): void;
    // (undocumented)
    useXDeprecatedProvider(onUsage: (message: string) => void): void;
}

// @public (undocumented)
class SchemaValidationException extends BaseException {
    constructor(errors?: SchemaValidatorError[], baseMessage?: string);
    // (undocumented)
    static createMessages(errors?: SchemaValidatorError[]): string[];
    // (undocumented)
    readonly errors: SchemaValidatorError[];
}

// @public (undocumented)
interface SchemaValidator {
    // (undocumented)
    (data: JsonValue, options?: SchemaValidatorOptions): Observable<SchemaValidatorResult>;
}

// @public (undocumented)
type SchemaValidatorError = Partial<ErrorObject>;

// @public (undocumented)
interface SchemaValidatorOptions {
    // (undocumented)
    applyPostTransforms?: boolean;
    // (undocumented)
    applyPreTransforms?: boolean;
    // (undocumented)
    withPrompts?: boolean;
}

// @public (undocumented)
interface SchemaValidatorResult {
    // (undocumented)
    data: JsonValue;
    // (undocumented)
    errors?: SchemaValidatorError[];
    // (undocumented)
    success: boolean;
}

// @public (undocumented)
class ScopedHost<T extends object> extends ResolverHost<T> {
    constructor(delegate: Host<T>, _root?: Path);
    // (undocumented)
    protected _resolve(path: Path): Path;
    // (undocumented)
    protected _root: Path;
}

// @public (undocumented)
interface ScreenviewOptions extends CustomDimensionsAndMetricsOptions {
    // (undocumented)
    appId?: string;
    // (undocumented)
    appInstallerId?: string;
    // (undocumented)
    appVersion?: string;
}

// @public
interface SimpleJobHandlerContext<A extends JsonValue, I extends JsonValue, O extends JsonValue> extends JobHandlerContext<A, I, O> {
    // (undocumented)
    createChannel: (name: string) => Observer<JsonValue>;
    // (undocumented)
    input: Observable<I>;
}

// @public
type SimpleJobHandlerFn<A extends JsonValue, I extends JsonValue, O extends JsonValue> = (input: A, context: SimpleJobHandlerContext<A, I, O>) => O | Promise<O> | Observable<O>;

// @public
class SimpleJobRegistry<MinimumArgumentValueT extends JsonValue = JsonValue, MinimumInputValueT extends JsonValue = JsonValue, MinimumOutputValueT extends JsonValue = JsonValue> implements Registry<MinimumArgumentValueT, MinimumInputValueT, MinimumOutputValueT> {
    // (undocumented)
    get<A extends MinimumArgumentValueT = MinimumArgumentValueT, I extends MinimumInputValueT = MinimumInputValueT, O extends MinimumOutputValueT = MinimumOutputValueT>(name: JobName): Observable<JobHandler<A, I, O> | null>;
    getJobNames(): JobName[];
    register<A extends MinimumArgumentValueT, I extends MinimumInputValueT, O extends MinimumOutputValueT>(name: JobName, handler: JobHandler<A, I, O>, options?: RegisterJobOptions): void;
    register<ArgumentT extends JsonValue, InputT extends JsonValue, OutputT extends JsonValue>(handler: JobHandler<ArgumentT, InputT, OutputT>, options?: RegisterJobOptions & {
        name: string;
    }): void;
    // (undocumented)
    protected _register<ArgumentT extends JsonValue, InputT extends JsonValue, OutputT extends JsonValue>(name: JobName, handler: JobHandler<ArgumentT, InputT, OutputT>, options: RegisterJobOptions): void;
}

// @public (undocumented)
class SimpleMemoryHost implements Host<{}> {
    constructor();
    // (undocumented)
    protected _cache: Map<Path, Stats<SimpleMemoryHostStats>>;
    // (undocumented)
    get capabilities(): HostCapabilities;
    // (undocumented)
    delete(path: Path): Observable<void>;
    // (undocumented)
    protected _delete(path: Path): void;
    // (undocumented)
    exists(path: Path): Observable<boolean>;
    // (undocumented)
    protected _exists(path: Path): boolean;
    // (undocumented)
    isDirectory(path: Path): Observable<boolean>;
    // (undocumented)
    protected _isDirectory(path: Path): boolean;
    // (undocumented)
    isFile(path: Path): Observable<boolean>;
    // (undocumented)
    protected _isFile(path: Path): boolean;
    // (undocumented)
    list(path: Path): Observable<PathFragment[]>;
    // (undocumented)
    protected _list(path: Path): PathFragment[];
    // (undocumented)
    protected _newDirStats(): {
        inspect(): string;
        isFile(): boolean;
        isDirectory(): boolean;
        size: number;
        atime: Date;
        ctime: Date;
        mtime: Date;
        birthtime: Date;
        content: null;
    };
    // (undocumented)
    protected _newFileStats(content: FileBuffer, oldStats?: Stats<SimpleMemoryHostStats>): {
        inspect(): string;
        isFile(): boolean;
        isDirectory(): boolean;
        size: number;
        atime: Date;
        ctime: Date;
        mtime: Date;
        birthtime: Date;
        content: ArrayBuffer;
    };
    // (undocumented)
    read(path: Path): Observable<FileBuffer>;
    // (undocumented)
    protected _read(path: Path): FileBuffer;
    // (undocumented)
    rename(from: Path, to: Path): Observable<void>;
    // (undocumented)
    protected _rename(from: Path, to: Path): void;
    // (undocumented)
    reset(): void;
    // (undocumented)
    stat(path: Path): Observable<Stats<{}> | null> | null;
    // (undocumented)
    protected _stat(path: Path): Stats<SimpleMemoryHostStats> | null;
    // (undocumented)
    protected _toAbsolute(path: Path): Path;
    // (undocumented)
    protected _updateWatchers(path: Path, type: HostWatchEventType): void;
    // (undocumented)
    watch(path: Path, options?: HostWatchOptions): Observable<HostWatchEvent> | null;
    // (undocumented)
    protected _watch(path: Path, options?: HostWatchOptions): Observable<HostWatchEvent>;
    // (undocumented)
    write(path: Path, content: FileBuffer): Observable<void>;
    protected _write(path: Path, content: FileBuffer): void;
}

// @public (undocumented)
interface SimpleMemoryHostStats {
    // (undocumented)
    readonly content: FileBuffer | null;
}

// @public
class SimpleScheduler<MinimumArgumentT extends JsonValue = JsonValue, MinimumInputT extends JsonValue = JsonValue, MinimumOutputT extends JsonValue = JsonValue> implements Scheduler<MinimumArgumentT, MinimumInputT, MinimumOutputT> {
    constructor(_jobRegistry: Registry<MinimumArgumentT, MinimumInputT, MinimumOutputT>, _schemaRegistry?: schema.SchemaRegistry);
    getDescription(name: JobName): Observable<JobDescription | null>;
    has(name: JobName): Observable<boolean>;
    // (undocumented)
    protected _jobRegistry: Registry<MinimumArgumentT, MinimumInputT, MinimumOutputT>;
    pause(): () => void;
    schedule<A extends MinimumArgumentT, I extends MinimumInputT, O extends MinimumOutputT>(name: JobName, argument: A, options?: ScheduleJobOptions): Job<A, I, O>;
    // (undocumented)
    protected _scheduleJob<A extends MinimumArgumentT, I extends MinimumInputT, O extends MinimumOutputT>(name: JobName, argument: A, options: ScheduleJobOptions, waitable: Observable<never>): Job<A, I, O>;
    // (undocumented)
    protected _schemaRegistry: schema.SchemaRegistry;
}

// @public (undocumented)
interface SmartDefaultProvider<T> {
    // (undocumented)
    (schema: JsonObject): T | Observable<T>;
}

// @public
export function split(path: Path): PathFragment[];

// @public (undocumented)
type Stats<T extends object = {}> = T & {
    isFile(): boolean;
    isDirectory(): boolean;
    readonly size: number;
    readonly atime: Date;
    readonly mtime: Date;
    readonly ctime: Date;
    readonly birthtime: Date;
};

// @public (undocumented)
namespace strategy {
    // (undocumented)
    type JobStrategy<A extends JsonValue = JsonValue, I extends JsonValue = JsonValue, O extends JsonValue = JsonValue> = (handler: JobHandler<A, I, O>, options?: Partial<Readonly<JobDescription>>) => JobHandler<A, I, O>;
    function memoize<A extends JsonValue = JsonValue, I extends JsonValue = JsonValue, O extends JsonValue = JsonValue>(replayMessages?: boolean): JobStrategy<A, I, O>;
    function reuse<A extends JsonValue = JsonValue, I extends JsonValue = JsonValue, O extends JsonValue = JsonValue>(replayMessages?: boolean): JobStrategy<A, I, O>;
    function serialize<A extends JsonValue = JsonValue, I extends JsonValue = JsonValue, O extends JsonValue = JsonValue>(): JobStrategy<A, I, O>;
}

declare namespace strings {
    export {
        decamelize,
        dasherize,
        camelize,
        classify,
        underscore,
        capitalize,
        levenshtein
    }
}
export { strings }

// @public (undocumented)
function stringToFileBuffer(str: string): FileBuffer;

// @public (undocumented)
function stripIndent(strings: TemplateStringsArray, ...values: any[]): string;

// @public (undocumented)
function stripIndents(strings: TemplateStringsArray, ...values: any[]): string;

// @public
class SyncDelegateHost<T extends object = {}> {
    constructor(_delegate: Host<T>);
    // (undocumented)
    get capabilities(): HostCapabilities;
    // (undocumented)
    get delegate(): Host<T>;
    // (undocumented)
    protected _delegate: Host<T>;
    // (undocumented)
    delete(path: Path): void;
    // (undocumented)
    protected _doSyncCall<ResultT>(observable: Observable<ResultT>): ResultT;
    // (undocumented)
    exists(path: Path): boolean;
    // (undocumented)
    isDirectory(path: Path): boolean;
    // (undocumented)
    isFile(path: Path): boolean;
    // (undocumented)
    list(path: Path): PathFragment[];
    // (undocumented)
    read(path: Path): FileBuffer;
    // (undocumented)
    rename(from: Path, to: Path): void;
    // (undocumented)
    stat(path: Path): Stats<T> | null;
    // (undocumented)
    watch(path: Path, options?: HostWatchOptions): Observable<HostWatchEvent> | null;
    // (undocumented)
    write(path: Path, content: FileBufferLike): void;
}

// @public (undocumented)
interface SyncHostHandler<StatsT extends object = {}> {
    // (undocumented)
    delete(path: Path): void;
    // (undocumented)
    exists(path: Path): boolean;
    // (undocumented)
    isDirectory(path: Path): boolean;
    // (undocumented)
    isFile(path: Path): boolean;
    // (undocumented)
    list(path: Path): PathFragment[];
    // (undocumented)
    read(path: Path): FileBuffer;
    // (undocumented)
    rename(from: Path, to: Path): void;
    // (undocumented)
    stat(path: Path): Stats<StatsT> | null;
    // (undocumented)
    write(path: Path, content: FileBufferLike): void;
}

// @public (undocumented)
class SynchronousDelegateExpectedException extends BaseException {
    constructor();
}

declare namespace tags {
    export {
        oneLine,
        indentBy,
        stripIndent,
        stripIndents,
        trimNewlines,
        TemplateTag
    }
}
export { tags }

// @public (undocumented)
interface TargetDefinition {
    // (undocumented)
    builder: string;
    // (undocumented)
    configurations?: Record<string, Record<string, JsonValue | undefined> | undefined>;
    // (undocumented)
    defaultConfiguration?: string;
    // (undocumented)
    options?: Record<string, JsonValue | undefined>;
}

// @public (undocumented)
class TargetDefinitionCollection extends DefinitionCollection<TargetDefinition> {
    constructor(initial?: Record<string, TargetDefinition>, listener?: DefinitionCollectionListener<TargetDefinition>);
    // (undocumented)
    add(definition: {
        name: string;
    } & TargetDefinition): TargetDefinition;
    // (undocumented)
    set(name: string, value: TargetDefinition): this;
}

// @public
export function template<T>(content: string, options?: TemplateOptions): (input: T) => string;

// @public
export interface TemplateAst {
    // (undocumented)
    children: TemplateAstNode[];
    // (undocumented)
    content: string;
    // (undocumented)
    fileName: string;
}

// @public
export interface TemplateAstBase {
    // (undocumented)
    end: Position;
    // (undocumented)
    start: Position;
}

// @public
export interface TemplateAstComment extends TemplateAstBase {
    // (undocumented)
    kind: 'comment';
    // (undocumented)
    text: string;
}

// @public
export interface TemplateAstContent extends TemplateAstBase {
    // (undocumented)
    content: string;
    // (undocumented)
    kind: 'content';
}

// @public
export interface TemplateAstEscape extends TemplateAstBase {
    // (undocumented)
    expression: string;
    // (undocumented)
    kind: 'escape';
}

// @public
export interface TemplateAstEvaluate extends TemplateAstBase {
    // (undocumented)
    expression: string;
    // (undocumented)
    kind: 'evaluate';
}

// @public
export interface TemplateAstInterpolate extends TemplateAstBase {
    // (undocumented)
    expression: string;
    // (undocumented)
    kind: 'interpolate';
}

// @public (undocumented)
export type TemplateAstNode = TemplateAstContent | TemplateAstEvaluate | TemplateAstComment | TemplateAstEscape | TemplateAstInterpolate;

// @public (undocumented)
export interface TemplateOptions {
    // (undocumented)
    fileName?: string;
    // (undocumented)
    module?: boolean | {
        exports: {};
    };
    // (undocumented)
    sourceMap?: boolean;
    // (undocumented)
    sourceRoot?: string;
    // (undocumented)
    sourceURL?: string;
}

// @public
export function templateParser(sourceText: string, fileName: string): TemplateAst;

// @public
interface TemplateTag<R = string> {
    // (undocumented)
    (template: TemplateStringsArray, ...substitutions: any[]): R;
}

// @public (undocumented)
namespace test {
    // (undocumented)
    class TestHost extends SimpleMemoryHost {
        // (undocumented)
        $exists(path: string): boolean;
        // (undocumented)
        $isDirectory(path: string): boolean;
        // (undocumented)
        $isFile(path: string): boolean;
        // (undocumented)
        $list(path: string): PathFragment[];
        // (undocumented)
        $read(path: string): string;
        // (undocumented)
        $write(path: string, content: string): void;
        constructor(map?: {
            [path: string]: string;
        });
        // (undocumented)
        clearRecords(): void;
        // (undocumented)
        clone(): TestHost;
        // (undocumented)
        protected _delete(path: Path): void;
        // (undocumented)
        protected _exists(path: Path): boolean;
        // (undocumented)
        get files(): Path[];
        // (undocumented)
        protected _isDirectory(path: Path): boolean;
        // (undocumented)
        protected _isFile(path: Path): boolean;
        // (undocumented)
        protected _list(path: Path): PathFragment[];
        // (undocumented)
        protected _read(path: Path): ArrayBuffer;
        // (undocumented)
        get records(): TestLogRecord[];
        // (undocumented)
        protected _records: TestLogRecord[];
        // (undocumented)
        protected _rename(from: Path, to: Path): void;
        // (undocumented)
        protected _stat(path: Path): Stats<SimpleMemoryHostStats> | null;
        // (undocumented)
        get sync(): SyncDelegateHost<{}>;
        // (undocumented)
        protected _sync: SyncDelegateHost<{}> | null;
        // (undocumented)
        protected _watch(path: Path, options?: HostWatchOptions): Observable<HostWatchEvent>;
        // (undocumented)
        protected _write(path: Path, content: FileBuffer): void;
    }
    // (undocumented)
    type TestLogRecord = {
        kind: 'write' | 'read' | 'delete' | 'list' | 'exists' | 'isDirectory' | 'isFile' | 'stat' | 'watch';
        path: Path;
    } | {
        kind: 'rename';
        from: Path;
        to: Path;
    };
}

// @public (undocumented)
interface TimingOptions extends CustomDimensionsAndMetricsOptions {
    // (undocumented)
    label?: string;
}

// @public (undocumented)
class TransformLogger extends Logger {
    constructor(name: string, transform: (stream: Observable<LogEntry>) => Observable<LogEntry>, parent?: Logger | null);
}

declare namespace transforms {
    export {
        addUndefinedDefaults
    }
}

// @public (undocumented)
function trimNewlines(strings: TemplateStringsArray, ...values: any[]): string;

// @public
function underscore(str: string): string;

// @public (undocumented)
export class UnimplementedException extends BaseException {
    constructor();
}

// @public (undocumented)
export class UnknownException extends BaseException {
    constructor(message: string);
}

// @public (undocumented)
export class UnsupportedPlatformException extends BaseException {
    constructor();
}

// @public (undocumented)
type UriHandler = (uri: string) => Observable<JsonObject> | Promise<JsonObject> | null | undefined;

declare namespace virtualFs {
    export {
        AliasHost,
        stringToFileBuffer,
        fileBufferToString,
        fileBuffer,
        createSyncHost,
        SyncHostHandler,
        Empty,
        FileBuffer,
        FileBufferLike,
        HostWatchOptions,
        HostWatchEventType,
        Stats,
        HostWatchEvent,
        HostCapabilities,
        ReadonlyHost,
        Host,
        SimpleMemoryHostStats,
        SimpleMemoryHost,
        ReplacementFunction,
        PatternMatchingHost,
        CordHostCreate,
        CordHostOverwrite,
        CordHostRename,
        CordHostDelete,
        CordHostRecord,
        CordHost,
        SafeReadonlyHost,
        ScopedHost,
        SynchronousDelegateExpectedException,
        SyncDelegateHost,
        ResolverHost,
        test
    }
}
export { virtualFs }

// @public
function visitJson<ContextT>(json: JsonValue, visitor: JsonVisitor, schema?: JsonSchema, refResolver?: ReferenceResolver<ContextT>, context?: ContextT): Observable<JsonValue>;

// @public (undocumented)
function visitJsonSchema(schema: JsonSchema, visitor: JsonSchemaVisitor): void;

// @public (undocumented)
export type WindowsPath = string & {
    __PRIVATE_DEVKIT_WINDOWS_PATH: void;
};

// @public (undocumented)
interface WorkspaceDefinition {
    // (undocumented)
    readonly extensions: Record<string, JsonValue | undefined>;
    // (undocumented)
    readonly projects: ProjectDefinitionCollection;
}

// @public
enum WorkspaceFormat {
    // (undocumented)
    JSON = 0
}

// @public (undocumented)
interface WorkspaceHost {
    // (undocumented)
    isDirectory(path: string): Promise<boolean>;
    // (undocumented)
    isFile(path: string): Promise<boolean>;
    // (undocumented)
    readFile(path: string): Promise<string>;
    // (undocumented)
    writeFile(path: string, data: string): Promise<void>;
}

declare namespace workspaces {
    export {
        WorkspaceHost,
        createWorkspaceHost,
        WorkspaceFormat,
        readWorkspace,
        writeWorkspace,
        WorkspaceDefinition,
        ProjectDefinition,
        TargetDefinition,
        DefinitionCollectionListener,
        ProjectDefinitionCollection,
        TargetDefinitionCollection
    }
}
export { workspaces }

// @public
function writeWorkspace(workspace: WorkspaceDefinition, host: WorkspaceHost, path?: string, format?: WorkspaceFormat): Promise<void>;

// (No @packageDocumentation comment for this package)

```
