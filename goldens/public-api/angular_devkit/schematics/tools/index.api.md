## API Report File for "@angular-devkit/schematics_tools"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { BaseException } from '@angular-devkit/core';
import { JsonObject } from '@angular-devkit/core';
import { JsonValue } from '@angular-devkit/core';
import { logging } from '@angular-devkit/core';
import { Observable } from 'rxjs';
import { Path } from '@angular-devkit/core';
import { PathFragment } from '@angular-devkit/core';
import { schema } from '@angular-devkit/core';
import { Subject } from 'rxjs';
import { Url } from 'url';
import { virtualFs } from '@angular-devkit/core';

// @public (undocumented)
export class CollectionCannotBeResolvedException extends BaseException {
    constructor(name: string);
}

// @public (undocumented)
export class CollectionMissingFieldsException extends BaseException {
    constructor(name: string);
}

// @public (undocumented)
export class CollectionMissingSchematicsMapException extends BaseException {
    constructor(name: string);
}

// @public (undocumented)
export type ContextTransform = (context: FileSystemSchematicContext) => FileSystemSchematicContext;

// @public
export class ExportStringRef<T> {
    constructor(ref: string, parentPath?: string, inner?: boolean);
    // (undocumented)
    get module(): string;
    // (undocumented)
    get path(): string;
    // (undocumented)
    get ref(): T | undefined;
}

// @public (undocumented)
export class FactoryCannotBeResolvedException extends BaseException {
    constructor(name: string);
}

// @public (undocumented)
export type FileSystemCollection = Collection<FileSystemCollectionDescription, FileSystemSchematicDescription>;

// @public (undocumented)
export type FileSystemCollectionDesc = CollectionDescription<FileSystemCollectionDescription>;

// @public (undocumented)
export interface FileSystemCollectionDescription {
    // (undocumented)
    readonly encapsulation?: boolean;
    // (undocumented)
    readonly name: string;
    // (undocumented)
    readonly path: string;
    // (undocumented)
    readonly schematics: {
        [name: string]: FileSystemSchematicDesc;
    };
    // (undocumented)
    readonly version?: string;
}

// @public
export type FileSystemEngine = Engine<FileSystemCollectionDescription, FileSystemSchematicDescription>;

// @public
export class FileSystemEngineHost extends FileSystemEngineHostBase {
    constructor(_root: string);
    // (undocumented)
    createTaskExecutor(name: string): Observable<TaskExecutor>;
    // (undocumented)
    hasTaskExecutor(name: string): boolean;
    // (undocumented)
    protected _resolveCollectionPath(name: string): string;
    // (undocumented)
    protected _resolveReferenceString(refString: string, parentPath: string): {
        ref: RuleFactory<{}>;
        path: string;
    } | null;
    // (undocumented)
    protected _root: string;
    // (undocumented)
    protected _transformCollectionDescription(name: string, desc: Partial<FileSystemCollectionDesc>): FileSystemCollectionDesc;
    // (undocumented)
    protected _transformSchematicDescription(name: string, _collection: FileSystemCollectionDesc, desc: Partial<FileSystemSchematicDesc>): FileSystemSchematicDesc;
}

// @public
export abstract class FileSystemEngineHostBase implements FileSystemEngineHost_2 {
    // (undocumented)
    createCollectionDescription(name: string, requester?: FileSystemCollectionDesc): FileSystemCollectionDesc;
    // (undocumented)
    createSchematicDescription(name: string, collection: FileSystemCollectionDesc): FileSystemSchematicDesc | null;
    // (undocumented)
    createSourceFromUrl(url: Url): Source | null;
    // (undocumented)
    createTaskExecutor(name: string): Observable<TaskExecutor>;
    // (undocumented)
    getSchematicRuleFactory<OptionT extends object>(schematic: FileSystemSchematicDesc, _collection: FileSystemCollectionDesc): RuleFactory<OptionT>;
    // (undocumented)
    hasTaskExecutor(name: string): boolean;
    // (undocumented)
    listSchematicNames(collection: FileSystemCollectionDesc, includeHidden?: boolean): string[];
    // (undocumented)
    registerContextTransform(t: ContextTransform): void;
    // (undocumented)
    registerOptionsTransform<T extends object | null, R extends object>(t: OptionTransform<T, R>): void;
    // (undocumented)
    registerTaskExecutor<T>(factory: TaskExecutorFactory<T>, options?: T): void;
    // (undocumented)
    protected abstract _resolveCollectionPath(name: string, requester?: string): string;
    // (undocumented)
    protected abstract _resolveReferenceString(name: string, parentPath: string, collectionDescription: FileSystemCollectionDesc): {
        ref: RuleFactory<{}>;
        path: string;
    } | null;
    // (undocumented)
    protected abstract _transformCollectionDescription(name: string, desc: Partial<FileSystemCollectionDesc>): FileSystemCollectionDesc;
    // (undocumented)
    transformContext(context: FileSystemSchematicContext): FileSystemSchematicContext;
    // (undocumented)
    transformOptions<OptionT extends object, ResultT extends object>(schematic: FileSystemSchematicDesc, options: OptionT, context?: FileSystemSchematicContext): Observable<ResultT>;
    // (undocumented)
    protected abstract _transformSchematicDescription(name: string, collection: FileSystemCollectionDesc, desc: Partial<FileSystemSchematicDesc>): FileSystemSchematicDesc;
}

// @public (undocumented)
export type FileSystemSchematic = Schematic<FileSystemCollectionDescription, FileSystemSchematicDescription>;

// @public (undocumented)
export type FileSystemSchematicContext = TypedSchematicContext<FileSystemCollectionDescription, FileSystemSchematicDescription>;

// @public (undocumented)
export type FileSystemSchematicDesc = SchematicDescription<FileSystemCollectionDescription, FileSystemSchematicDescription>;

// @public (undocumented)
export interface FileSystemSchematicDescription extends FileSystemSchematicJsonDescription {
    // (undocumented)
    readonly factoryFn: RuleFactory<{}>;
    // (undocumented)
    readonly path: string;
    // (undocumented)
    readonly schemaJson?: JsonObject;
}

// @public (undocumented)
export interface FileSystemSchematicJsonDescription {
    // (undocumented)
    readonly aliases?: string[];
    // (undocumented)
    readonly collection: FileSystemCollectionDescription;
    // (undocumented)
    readonly description: string;
    // (undocumented)
    readonly extends?: string;
    // (undocumented)
    readonly factory: string;
    // (undocumented)
    readonly name: string;
    // (undocumented)
    readonly schema?: string;
}

// @public (undocumented)
export class InvalidCollectionJsonException extends BaseException {
    constructor(_name: string, path: string, jsonException?: Error);
}

// @public
export class NodeModulesEngineHost extends FileSystemEngineHostBase {
    constructor(paths?: string[] | undefined);
    // (undocumented)
    protected _resolveCollectionPath(name: string, requester?: string): string;
    // (undocumented)
    protected _resolveReferenceString(refString: string, parentPath: string, collectionDescription?: FileSystemCollectionDesc): {
        ref: RuleFactory<{}>;
        path: string;
    } | null;
    // (undocumented)
    protected _transformCollectionDescription(name: string, desc: Partial<FileSystemCollectionDesc>): FileSystemCollectionDesc;
    // (undocumented)
    protected _transformSchematicDescription(name: string, _collection: FileSystemCollectionDesc, desc: Partial<FileSystemSchematicDesc>): FileSystemSchematicDesc;
}

// @public
export class NodeModulesTestEngineHost extends NodeModulesEngineHost {
    // (undocumented)
    clearTasks(): void;
    // (undocumented)
    registerCollection(name: string, path: string): void;
    // (undocumented)
    protected _resolveCollectionPath(name: string, requester?: string): string;
    // (undocumented)
    get tasks(): TaskConfiguration<{}>[];
    // (undocumented)
    transformContext(context: FileSystemSchematicContext): FileSystemSchematicContext;
}

// @public (undocumented)
export class NodePackageDoesNotSupportSchematics extends BaseException {
    constructor(name: string);
}

// @public
export class NodeWorkflow extends workflow.BaseWorkflow {
    constructor(root: string, options: NodeWorkflowOptions);
    constructor(host: virtualFs.Host, options: NodeWorkflowOptions & {
        root?: Path;
    });
    // (undocumented)
    get engine(): FileSystemEngine;
    // (undocumented)
    get engineHost(): NodeModulesEngineHost;
}

// @public (undocumented)
export interface NodeWorkflowOptions {
    // (undocumented)
    dryRun?: boolean;
    // (undocumented)
    engineHostCreator?: (options: NodeWorkflowOptions) => NodeModulesEngineHost;
    // (undocumented)
    force?: boolean;
    // (undocumented)
    optionTransforms?: OptionTransform<Record<string, unknown> | null, object>[];
    // (undocumented)
    packageManager?: string;
    // (undocumented)
    packageManagerForce?: boolean;
    // (undocumented)
    packageRegistry?: string;
    // (undocumented)
    registry?: schema.CoreSchemaRegistry;
    // (undocumented)
    resolvePaths?: string[];
    // (undocumented)
    schemaValidation?: boolean;
}

// @public (undocumented)
export type OptionTransform<T extends object | null, R extends object> = (schematic: FileSystemSchematicDescription, options: T, context?: FileSystemSchematicContext) => Observable<R> | PromiseLike<R> | R;

// @public (undocumented)
export class SchematicMissingDescriptionException extends BaseException {
    constructor(name: string);
}

// @public (undocumented)
export class SchematicMissingFactoryException extends BaseException {
    constructor(name: string);
}

// @public (undocumented)
export class SchematicMissingFieldsException extends BaseException {
    constructor(name: string);
}

// @public (undocumented)
export class SchematicNameCollisionException extends BaseException {
    constructor(name: string);
}

// @public (undocumented)
export function validateOptionsWithSchema(registry: schema.SchemaRegistry): <T extends {} | null>(schematic: FileSystemSchematicDescription, options: T, context?: FileSystemSchematicContext) => Observable<T>;

// (No @packageDocumentation comment for this package)

```
